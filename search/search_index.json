{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"backoff","text":"<p>Function decoration for backoff and retry</p> <p>This module provides function decorators which can be used to wrap a function such that it will be retried until some condition is met. It is meant to be of use when accessing unreliable resources with the potential for intermittent failures (network resources, external APIs, etc).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Simple decorators - Easy-to-use <code>@backoff.on_exception</code> and <code>@backoff.on_predicate</code> decorators</li> <li>Multiple wait strategies - Exponential, fibonacci, constant, and runtime-configurable strategies</li> <li>Flexible configuration - Control retry limits with <code>max_time</code>, <code>max_tries</code>, and custom give-up conditions</li> <li>Event handlers - Hook into retry lifecycle with <code>on_success</code>, <code>on_backoff</code>, and <code>on_giveup</code> callbacks</li> <li>Async support - Full support for <code>asyncio</code> coroutines</li> <li>Type hints - Fully typed for better IDE support</li> <li>Battle-tested - Used in production by thousands of projects</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install via pip:</p> <pre><code>pip install backoff\n</code></pre> <p>Basic retry on exception:</p> <pre><code>import backoff\nimport requests\n\n@backoff.on_exception(backoff.expo,\n                      requests.exceptions.RequestException,\n                      max_time=60)\ndef get_url(url):\n    return requests.get(url)\n</code></pre> <p>This will retry the function with exponential backoff whenever a <code>RequestException</code> is raised, giving up after 60 seconds.</p>"},{"location":"#common-use-cases","title":"Common Use Cases","text":""},{"location":"#api-rate-limiting","title":"API Rate Limiting","text":"<pre><code>@backoff.on_predicate(\n    backoff.runtime,\n    predicate=lambda r: r.status_code == 429,\n    value=lambda r: int(r.headers.get(\"Retry-After\", 1)),\n    jitter=None,\n)\ndef call_api():\n    return requests.get(api_url)\n</code></pre>"},{"location":"#database-retries","title":"Database Retries","text":"<pre><code>@backoff.on_exception(backoff.expo,\n                      sqlalchemy.exc.OperationalError,\n                      max_tries=5)\ndef query_database():\n    return session.query(Model).all()\n</code></pre>"},{"location":"#polling-for-results","title":"Polling for Results","text":"<pre><code>@backoff.on_predicate(backoff.constant,\n                      lambda result: result is None,\n                      interval=2,\n                      max_time=300)\ndef poll_for_result(job_id):\n    return check_job_status(job_id)\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Guide - Detailed tutorial</li> <li>User Guide - Complete reference</li> <li>Examples - Real-world patterns</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"#project-links","title":"Project Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Issue Tracker</li> <li>Changelog</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Real-world examples of using backoff in production.</p>"},{"location":"examples/#httpapi-calls","title":"HTTP/API Calls","text":""},{"location":"examples/#basic-api-retry","title":"Basic API Retry","text":"<pre><code>import backoff\nimport requests\n\n@backoff.on_exception(backoff.expo,\n                      requests.exceptions.RequestException,\n                      max_time=60)\ndef fetch_data(url):\n    response = requests.get(url)\n    response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"examples/#rate-limiting-with-retry-after","title":"Rate Limiting with Retry-After","text":"<pre><code>@backoff.on_predicate(\n    backoff.runtime,\n    predicate=lambda r: r.status_code == 429,\n    value=lambda r: int(r.headers.get(\"Retry-After\", 1)),\n    jitter=None,\n    max_tries=10\n)\ndef rate_limited_api_call(endpoint):\n    return requests.get(endpoint)\n</code></pre>"},{"location":"examples/#conditional-retry-on-status-codes","title":"Conditional Retry on Status Codes","text":"<pre><code>def should_retry(response):\n    # Retry on 5xx and 429, but not 4xx\n    return response.status_code &gt;= 500 or response.status_code == 429\n\n@backoff.on_predicate(\n    backoff.expo,\n    should_retry,\n    max_time=120\n)\ndef resilient_api_call(url):\n    response = requests.get(url)\n    if 400 &lt;= response.status_code &lt; 500 and response.status_code != 429:\n        response.raise_for_status()  # Don't retry client errors\n    return response\n</code></pre>"},{"location":"examples/#database-operations","title":"Database Operations","text":""},{"location":"examples/#connection-retry","title":"Connection Retry","text":"<pre><code>import sqlalchemy\nfrom sqlalchemy.exc import OperationalError, TimeoutError\n\n@backoff.on_exception(\n    backoff.expo,\n    (OperationalError, TimeoutError),\n    max_tries=5,\n    max_time=30\n)\ndef connect_to_database(connection_string):\n    engine = sqlalchemy.create_engine(connection_string)\n    connection = engine.connect()\n    return connection\n</code></pre>"},{"location":"examples/#transaction-retry-with-deadlock-handling","title":"Transaction Retry with Deadlock Handling","text":"<pre><code>from sqlalchemy.exc import DBAPIError\n\ndef is_deadlock(e):\n    \"\"\"Check if exception is a deadlock\"\"\"\n    if isinstance(e, DBAPIError):\n        return \"deadlock\" in str(e).lower()\n    return False\n\n@backoff.on_exception(\n    backoff.expo,\n    DBAPIError,\n    giveup=lambda e: not is_deadlock(e),\n    max_tries=3\n)\ndef execute_transaction(session, operation):\n    try:\n        result = operation(session)\n        session.commit()\n        return result\n    except Exception:\n        session.rollback()\n        raise\n</code></pre>"},{"location":"examples/#asyncawait","title":"Async/Await","text":""},{"location":"examples/#async-http-client","title":"Async HTTP Client","text":"<pre><code>import aiohttp\nimport backoff\n\n@backoff.on_exception(\n    backoff.expo,\n    aiohttp.ClientError,\n    max_time=60\n)\nasync def fetch_async(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            return await response.json()\n</code></pre>"},{"location":"examples/#async-database-operations","title":"Async Database Operations","text":"<pre><code>import asyncpg\n\n@backoff.on_exception(\n    backoff.expo,\n    asyncpg.PostgresError,\n    max_tries=5\n)\nasync def query_async(pool, query):\n    async with pool.acquire() as conn:\n        return await conn.fetch(query)\n</code></pre>"},{"location":"examples/#multiple-async-tasks-with-individual-retries","title":"Multiple Async Tasks with Individual Retries","text":"<pre><code>@backoff.on_exception(backoff.expo, aiohttp.ClientError, max_tries=3)\nasync def fetch_with_retry(session, url):\n    async with session.get(url) as response:\n        return await response.json()\n\nasync def fetch_all(urls):\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_with_retry(session, url) for url in urls]\n        return await asyncio.gather(*tasks, return_exceptions=True)\n</code></pre>"},{"location":"examples/#polling-and-resource-waiting","title":"Polling and Resource Waiting","text":""},{"location":"examples/#poll-for-job-completion","title":"Poll for Job Completion","text":"<pre><code>@backoff.on_predicate(\n    backoff.constant,\n    lambda job: job[\"status\"] != \"complete\",\n    interval=5,\n    max_time=600\n)\ndef wait_for_job(job_id):\n    response = requests.get(f\"/api/jobs/{job_id}\")\n    return response.json()\n</code></pre>"},{"location":"examples/#wait-for-resource-availability","title":"Wait for Resource Availability","text":"<pre><code>@backoff.on_predicate(\n    backoff.fibo,\n    lambda result: not result,\n    max_value=30,\n    max_time=300\n)\ndef wait_for_resource(resource_id):\n    try:\n        resource = get_resource(resource_id)\n        return resource if resource.is_ready() else None\n    except ResourceNotFound:\n        return None\n</code></pre>"},{"location":"examples/#message-queue-polling","title":"Message Queue Polling","text":"<pre><code>@backoff.on_predicate(\n    backoff.constant,\n    lambda messages: len(messages) == 0,\n    interval=2,\n    jitter=None\n)\ndef poll_queue(queue_name):\n    return message_queue.receive(queue_name, max_messages=10)\n</code></pre>"},{"location":"examples/#cloud-services","title":"Cloud Services","text":""},{"location":"examples/#aws-s3-operations","title":"AWS S3 Operations","text":"<pre><code>import boto3\nfrom botocore.exceptions import ClientError\n\ndef is_throttled(e):\n    if isinstance(e, ClientError):\n        return e.response['Error']['Code'] in ['SlowDown', 'RequestLimitExceeded']\n    return False\n\n@backoff.on_exception(\n    backoff.expo,\n    ClientError,\n    giveup=lambda e: not is_throttled(e),\n    max_tries=5\n)\ndef upload_to_s3(bucket, key, data):\n    s3 = boto3.client('s3')\n    s3.put_object(Bucket=bucket, Key=key, Body=data)\n</code></pre>"},{"location":"examples/#dynamodb-with-exponential-backoff","title":"DynamoDB with Exponential Backoff","text":"<pre><code>@backoff.on_exception(\n    backoff.expo,\n    ClientError,\n    giveup=lambda e: e.response['Error']['Code'] != 'ProvisionedThroughputExceededException',\n    max_time=30\n)\ndef write_to_dynamodb(table_name, item):\n    dynamodb = boto3.resource('dynamodb')\n    table = dynamodb.Table(table_name)\n    table.put_item(Item=item)\n</code></pre>"},{"location":"examples/#testing-and-debugging","title":"Testing and Debugging","text":""},{"location":"examples/#logging-retry-events","title":"Logging Retry Events","text":"<pre><code>import logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef log_retry(details):\n    logger.warning(\n        f\"Backing off {details['wait']:.1f}s after {details['tries']} tries \"\n        f\"calling {details['target'].__name__}\"\n    )\n\ndef log_giveup(details):\n    logger.error(\n        f\"Giving up after {details['tries']} tries \"\n        f\"and {details['elapsed']:.1f}s\"\n    )\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=log_retry,\n    on_giveup=log_giveup,\n    max_tries=5\n)\ndef flaky_function():\n    pass\n</code></pre>"},{"location":"examples/#metrics-collection","title":"Metrics Collection","text":"<pre><code>retry_metrics = {'total_retries': 0, 'giveups': 0}\n\ndef count_retry(details):\n    retry_metrics['total_retries'] += 1\n\ndef count_giveup(details):\n    retry_metrics['giveups'] += 1\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=count_retry,\n    on_giveup=count_giveup,\n    max_tries=3\n)\ndef monitored_function():\n    pass\n</code></pre>"},{"location":"examples/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"examples/#combining-multiple-decorators","title":"Combining Multiple Decorators","text":"<pre><code># Separate retry logic for different failure modes\n@backoff.on_predicate(\n    backoff.fibo,\n    lambda result: result is None,\n    max_value=13\n)\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.HTTPError,\n    giveup=lambda e: 400 &lt;= e.response.status_code &lt; 500,\n    max_time=60\n)\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.Timeout,\n    max_tries=3\n)\ndef comprehensive_retry(url):\n    response = requests.get(url)\n    response.raise_for_status()\n    data = response.json()\n    return data if data.get('ready') else None\n</code></pre>"},{"location":"examples/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<pre><code>class CircuitBreaker:\n    def __init__(self, failure_threshold=5, timeout=60):\n        self.failure_count = 0\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.opened_at = None\n\n    def should_attempt(self):\n        if self.opened_at is None:\n            return True\n        if time.time() - self.opened_at &gt; self.timeout:\n            self.opened_at = None\n            self.failure_count = 0\n            return True\n        return False\n\n    def record_failure(self):\n        self.failure_count += 1\n        if self.failure_count &gt;= self.failure_threshold:\n            self.opened_at = time.time()\n\ncircuit_breaker = CircuitBreaker()\n\ndef check_circuit(e):\n    circuit_breaker.record_failure()\n    return not circuit_breaker.should_attempt()\n\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    giveup=check_circuit,\n    max_tries=5\n)\ndef protected_api_call(url):\n    if not circuit_breaker.should_attempt():\n        raise Exception(\"Circuit breaker is open\")\n    return requests.get(url)\n</code></pre>"},{"location":"examples/#dynamic-configuration","title":"Dynamic Configuration","text":"<pre><code>class RetryConfig:\n    def __init__(self):\n        self.max_time = 60\n        self.max_tries = 5\n\n    def get_max_time(self):\n        return self.max_time\n\n    def get_max_tries(self):\n        return self.max_tries\n\nconfig = RetryConfig()\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    max_time=lambda: config.get_max_time(),\n    max_tries=lambda: config.get_max_tries()\n)\ndef configurable_retry():\n    pass\n\n# Can update config at runtime\nconfig.max_time = 120\n</code></pre>"},{"location":"examples/#error-handling","title":"Error Handling","text":""},{"location":"examples/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    max_tries=3,\n    raise_on_giveup=False\n)\ndef optional_api_call(url):\n    return requests.get(url)\n\n# Use with fallback\nresult = optional_api_call(primary_url)\nif result is None:\n    result = get_from_cache()\n</code></pre>"},{"location":"examples/#custom-exception-on-giveup","title":"Custom Exception on Giveup","text":"<pre><code>class RetryExhaustedError(Exception):\n    pass\n\ndef raise_custom_error(details):\n    raise RetryExhaustedError(\n        f\"Failed after {details['tries']} attempts\"\n    )\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_giveup=raise_custom_error,\n    max_tries=5,\n    raise_on_giveup=False\n)\ndef critical_operation():\n    pass\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-backoff","title":"What is backoff?","text":"<p>Backoff is a Python library that provides decorators for retrying functions when they fail or don't meet certain conditions. It's commonly used for handling transient failures in network requests, API calls, database operations, and other unreliable operations.</p>"},{"location":"faq/#when-should-i-use-backoff","title":"When should I use backoff?","text":"<p>Use backoff when:</p> <ul> <li>Making network requests that might fail temporarily</li> <li>Calling external APIs with rate limits</li> <li>Connecting to databases that might be temporarily unavailable</li> <li>Polling for results from async operations</li> <li>Handling any operation that might fail transiently</li> </ul>"},{"location":"faq/#how-is-backoff-different-from-just-using-a-loop","title":"How is backoff different from just using a loop?","text":"<p>Backoff provides:</p> <ul> <li>Automatic retry logic with configurable strategies</li> <li>Built-in exponential/fibonacci/constant wait patterns</li> <li>Jitter to prevent thundering herd</li> <li>Event handlers for logging and monitoring</li> <li>Clean decorator syntax</li> <li>Async/await support</li> <li>Type hints and better IDE support</li> </ul>"},{"location":"faq/#configuration-questions","title":"Configuration Questions","text":""},{"location":"faq/#how-do-i-limit-the-number-of-retries","title":"How do I limit the number of retries?","text":"<p>Use <code>max_tries</code>:</p> <pre><code>@backoff.on_exception(backoff.expo, Exception, max_tries=5)\ndef my_function():\n    pass\n</code></pre>"},{"location":"faq/#how-do-i-limit-the-total-time-spent-retrying","title":"How do I limit the total time spent retrying?","text":"<p>Use <code>max_time</code> (in seconds):</p> <pre><code>@backoff.on_exception(backoff.expo, Exception, max_time=60)\ndef my_function():\n    pass\n</code></pre>"},{"location":"faq/#can-i-use-both-max_tries-and-max_time","title":"Can I use both max_tries and max_time?","text":"<p>Yes! The function will stop retrying when either limit is reached:</p> <pre><code>@backoff.on_exception(backoff.expo, Exception, max_tries=10, max_time=300)\ndef my_function():\n    pass\n</code></pre>"},{"location":"faq/#how-do-i-disable-jitter","title":"How do I disable jitter?","text":"<p>Pass <code>jitter=None</code>:</p> <pre><code>@backoff.on_exception(backoff.expo, Exception, jitter=None)\ndef my_function():\n    pass\n</code></pre> <p>This gives you predictable wait times, useful for testing or when exact timing matters.</p>"},{"location":"faq/#exception-handling","title":"Exception Handling","text":""},{"location":"faq/#which-exceptions-should-i-retry","title":"Which exceptions should I retry?","text":"<p>Retry transient failures (temporary issues):</p> <ul> <li>\u2705 Network timeouts</li> <li>\u2705 Connection errors</li> <li>\u2705 5xx server errors</li> <li>\u2705 429 rate limiting</li> <li>\u2705 Database connection failures</li> </ul> <p>Don't retry permanent failures:</p> <ul> <li>\u274c 4xx client errors (except 429)</li> <li>\u274c Authentication failures</li> <li>\u274c Validation errors</li> <li>\u274c Resource not found errors</li> </ul>"},{"location":"faq/#how-do-i-stop-retrying-for-certain-errors","title":"How do I stop retrying for certain errors?","text":"<p>Use the <code>giveup</code> parameter:</p> <pre><code>def is_permanent_error(e):\n    if hasattr(e, 'response'):\n        return 400 &lt;= e.response.status_code &lt; 500\n    return False\n\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    giveup=is_permanent_error\n)\ndef api_call():\n    pass\n</code></pre>"},{"location":"faq/#what-happens-when-retries-are-exhausted","title":"What happens when retries are exhausted?","text":"<p>By default (<code>raise_on_giveup=True</code>), the original exception is re-raised. You can disable this:</p> <pre><code>@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    max_tries=5,\n    raise_on_giveup=False\n)\ndef my_function():\n    pass\n\nresult = my_function()  # Returns None if all retries fail\n</code></pre>"},{"location":"faq/#can-i-retry-multiple-exception-types","title":"Can I retry multiple exception types?","text":"<p>Yes, pass a tuple:</p> <pre><code>@backoff.on_exception(\n    backoff.expo,\n    (TimeoutError, ConnectionError, requests.exceptions.RequestException)\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"faq/#wait-strategy-questions","title":"Wait Strategy Questions","text":""},{"location":"faq/#which-wait-strategy-should-i-use","title":"Which wait strategy should I use?","text":"<ul> <li>Exponential (<code>backoff.expo</code>) - Most common, fast backoff for network/API calls</li> <li>Fibonacci (<code>backoff.fibo</code>) - Gentler backoff, good for polling</li> <li>Constant (<code>backoff.constant</code>) - Fixed intervals, good for regular polling</li> <li>Runtime (<code>backoff.runtime</code>) - Server-directed wait times (Retry-After headers)</li> </ul>"},{"location":"faq/#what-is-jitter-and-why-is-it-important","title":"What is jitter and why is it important?","text":"<p>Jitter adds randomness to wait times to prevent the \"thundering herd\" problem (many clients retrying simultaneously). The default <code>full_jitter</code> uses AWS's algorithm where actual wait time is random between 0 and the calculated wait time.</p>"},{"location":"faq/#how-do-i-respect-retry-after-headers","title":"How do I respect Retry-After headers?","text":"<p>Use <code>backoff.runtime</code>:</p> <pre><code>@backoff.on_predicate(\n    backoff.runtime,\n    predicate=lambda r: r.status_code == 429,\n    value=lambda r: int(r.headers.get(\"Retry-After\", 1)),\n    jitter=None\n)\ndef api_call():\n    return requests.get(url)\n</code></pre>"},{"location":"faq/#async-questions","title":"Async Questions","text":""},{"location":"faq/#does-backoff-work-with-asyncawait","title":"Does backoff work with async/await?","text":"<p>Yes! Just decorate async functions:</p> <pre><code>@backoff.on_exception(backoff.expo, aiohttp.ClientError)\nasync def fetch_data(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            return await response.json()\n</code></pre>"},{"location":"faq/#can-event-handlers-be-async","title":"Can event handlers be async?","text":"<p>Yes, you can use async functions for <code>on_success</code>, <code>on_backoff</code>, and <code>on_giveup</code>:</p> <pre><code>async def log_retry(details):\n    await async_logger.log(f\"Retry {details['tries']}\")\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=log_retry\n)\nasync def my_function():\n    pass\n</code></pre>"},{"location":"faq/#logging-and-monitoring","title":"Logging and Monitoring","text":""},{"location":"faq/#how-do-i-log-retry-attempts","title":"How do I log retry attempts?","text":"<p>Use event handlers:</p> <pre><code>def log_backoff(details):\n    logger.warning(f\"Retry {details['tries']} after {details['elapsed']:.1f}s\")\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=log_backoff\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"faq/#can-i-use-the-default-logger","title":"Can I use the default logger?","text":"<p>Yes, backoff has a default logger. Enable it:</p> <pre><code>import logging\n\nlogging.getLogger('backoff').addHandler(logging.StreamHandler())\nlogging.getLogger('backoff').setLevel(logging.INFO)\n</code></pre>"},{"location":"faq/#how-do-i-disable-all-logging","title":"How do I disable all logging?","text":"<p>Pass <code>logger=None</code>:</p> <pre><code>@backoff.on_exception(backoff.expo, Exception, logger=None)\ndef my_function():\n    pass\n</code></pre>"},{"location":"faq/#what-information-is-available-in-event-handlers","title":"What information is available in event handlers?","text":"<p>Event handlers receive a dict with:</p> <ul> <li><code>target</code> - Function being called</li> <li><code>args</code> - Positional arguments</li> <li><code>kwargs</code> - Keyword arguments</li> <li><code>tries</code> - Number of attempts</li> <li><code>elapsed</code> - Total elapsed time</li> <li><code>wait</code> - Time to wait (on_backoff only)</li> <li><code>value</code> - Return value (on_predicate only)</li> <li><code>exception</code> - Exception raised (on_exception only)</li> </ul>"},{"location":"faq/#performance-questions","title":"Performance Questions","text":""},{"location":"faq/#does-backoff-add-overhead","title":"Does backoff add overhead?","text":"<p>Minimal. The decorator overhead is negligible compared to typical network/database operation times.</p>"},{"location":"faq/#can-i-use-backoff-in-production","title":"Can I use backoff in production?","text":"<p>Absolutely! Backoff is used in production by thousands of projects. It's stable, well-tested, and maintained.</p>"},{"location":"faq/#how-many-retries-is-too-many","title":"How many retries is too many?","text":"<p>It depends on your use case:</p> <ul> <li>Quick operations: 3-5 retries</li> <li>Network requests: 5-10 retries with max_time=60s</li> <li>Long polling: Higher retries or no limit with max_time</li> </ul>"},{"location":"faq/#will-backoff-cause-memory-leaks","title":"Will backoff cause memory leaks?","text":"<p>No. Backoff doesn't store state between function calls.</p>"},{"location":"faq/#advanced-usage","title":"Advanced Usage","text":""},{"location":"faq/#can-i-combine-multiple-decorators","title":"Can I combine multiple decorators?","text":"<p>Yes! Stack them for complex retry logic:</p> <pre><code>@backoff.on_predicate(backoff.fibo, lambda x: x is None)\n@backoff.on_exception(backoff.expo, HTTPError)\n@backoff.on_exception(backoff.expo, Timeout)\ndef complex_operation():\n    pass\n</code></pre> <p>Decorators are applied inside-out (bottom to top).</p>"},{"location":"faq/#how-do-i-implement-a-circuit-breaker","title":"How do I implement a circuit breaker?","text":"<p>Use the <code>giveup</code> callback with stateful logic:</p> <pre><code>class CircuitBreaker:\n    def __init__(self, threshold=5):\n        self.failures = 0\n        self.threshold = threshold\n        self.opened_at = None\n\n    def should_giveup(self, e):\n        self.failures += 1\n        if self.failures &gt;= self.threshold:\n            self.opened_at = time.time()\n            return True\n        return False\n\nbreaker = CircuitBreaker()\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    giveup=breaker.should_giveup\n)\ndef protected_call():\n    pass\n</code></pre>"},{"location":"faq/#can-i-use-runtime-configuration","title":"Can I use runtime configuration?","text":"<p>Yes, pass callables instead of values:</p> <pre><code>def get_max_time():\n    return app.config['RETRY_MAX_TIME']\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    max_time=get_max_time\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"faq/#how-do-i-test-code-that-uses-backoff","title":"How do I test code that uses backoff?","text":"<ol> <li>Set <code>max_tries=1</code> or <code>jitter=None</code> for predictable tests</li> <li>Mock the underlying operation to control failures</li> <li>Use event handlers to verify retry behavior</li> </ol> <pre><code>def test_retry_behavior():\n    attempts = []\n\n    def track_attempts(details):\n        attempts.append(details['tries'])\n\n    @backoff.on_exception(\n        backoff.constant,\n        ValueError,\n        on_backoff=track_attempts,\n        max_tries=3,\n        interval=0.01\n    )\n    def failing_function():\n        raise ValueError(\"Test error\")\n\n    with pytest.raises(ValueError):\n        failing_function()\n\n    assert len(attempts) == 2  # Backoff called 2 times (3 tries total)\n</code></pre>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#why-is-my-function-not-retrying","title":"Why is my function not retrying?","text":"<p>Check:</p> <ol> <li>Are you catching the right exception?</li> <li>Is <code>max_tries</code> or <code>max_time</code> too low?</li> <li>Is your <code>giveup</code> function returning True?</li> <li>Are you actually calling the decorated function?</li> </ol>"},{"location":"faq/#why-are-wait-times-not-what-i-expect","title":"Why are wait times not what I expect?","text":"<p>The default <code>full_jitter</code> adds randomness. To see exact wait times, disable jitter:</p> <pre><code>@backoff.on_exception(backoff.expo, Exception, jitter=None)\n</code></pre>"},{"location":"faq/#can-i-see-whats-happening-during-retries","title":"Can I see what's happening during retries?","text":"<p>Enable logging or use event handlers:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\nlogging.getLogger('backoff').setLevel(logging.DEBUG)\n</code></pre> <p>Or:</p> <pre><code>@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=lambda d: print(f\"Try {d['tries']}, wait {d['wait']:.1f}s\")\n)\n</code></pre>"},{"location":"faq/#migration-and-alternatives","title":"Migration and Alternatives","text":""},{"location":"faq/#how-does-backoff-compare-to-tenacity","title":"How does backoff compare to tenacity?","text":"<p>Both are excellent retry libraries. Backoff:</p> <ul> <li>Simpler, more focused API</li> <li>Decorator-first design</li> <li>Lighter weight</li> <li>More emphasis on wait strategies</li> </ul> <p>Tenacity:</p> <ul> <li>More features (stop/wait/retry strategies)</li> <li>More complex configuration options</li> <li>More actively maintained recently</li> </ul>"},{"location":"faq/#can-i-migrate-from-retrying-or-retry","title":"Can I migrate from retrying or retry?","text":"<p>Yes, but the API is different. Backoff uses decorators with different parameter names.</p>"},{"location":"faq/#is-backoff-still-maintained","title":"Is backoff still maintained?","text":"<p>Yes, backoff is actively maintained. Check the GitHub repository for recent activity.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will walk you through the basics of using backoff for retrying functions.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install backoff using pip:</p> <pre><code>pip install backoff\n</code></pre>"},{"location":"getting-started/#basic-concepts","title":"Basic Concepts","text":"<p>Backoff provides two main decorators:</p> <ol> <li><code>@backoff.on_exception</code> - Retry when a specific exception is raised</li> <li><code>@backoff.on_predicate</code> - Retry when a condition is true about the return value</li> </ol>"},{"location":"getting-started/#your-first-retry","title":"Your First Retry","text":"<p>Let's start with a simple example - retrying a network request:</p> <pre><code>import backoff\nimport requests\n\n@backoff.on_exception(backoff.expo,\n                      requests.exceptions.RequestException)\ndef get_url(url):\n    return requests.get(url)\n</code></pre> <p>This decorator will:</p> <ul> <li>Retry whenever <code>RequestException</code> (or any subclass) is raised</li> <li>Use exponential backoff (wait times: 1s, 2s, 4s, 8s, 16s, ...)</li> <li>Keep retrying indefinitely until success</li> </ul>"},{"location":"getting-started/#adding-limits","title":"Adding Limits","text":"<p>In production, you'll want to limit retries:</p> <pre><code>@backoff.on_exception(backoff.expo,\n                      requests.exceptions.RequestException,\n                      max_time=60,\n                      max_tries=5)\ndef get_url(url):\n    return requests.get(url)\n</code></pre> <p>This will give up after either:</p> <ul> <li>60 seconds have elapsed, OR</li> <li>5 retry attempts have been made</li> </ul>"},{"location":"getting-started/#handling-multiple-exceptions","title":"Handling Multiple Exceptions","text":"<p>You can retry on multiple exception types:</p> <pre><code>@backoff.on_exception(\n    backoff.expo,\n    (requests.exceptions.Timeout,\n     requests.exceptions.ConnectionError),\n    max_time=30\n)\ndef get_url(url):\n    return requests.get(url)\n</code></pre>"},{"location":"getting-started/#conditional-give-up","title":"Conditional Give-Up","text":"<p>Sometimes you need custom logic to decide when to stop retrying:</p> <pre><code>def fatal_code(e):\n    \"\"\"Don't retry on 4xx errors\"\"\"\n    return 400 &lt;= e.response.status_code &lt; 500\n\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    max_time=300,\n    giveup=fatal_code\n)\ndef get_url(url):\n    return requests.get(url)\n</code></pre>"},{"location":"getting-started/#using-on_predicate","title":"Using on_predicate","text":"<p>For polling or checking return values:</p> <pre><code>@backoff.on_predicate(backoff.constant,\n                      lambda result: result is None,\n                      interval=5,\n                      max_time=300)\ndef check_job_status(job_id):\n    response = requests.get(f\"/jobs/{job_id}\")\n    if response.json()[\"status\"] == \"complete\":\n        return response.json()\n    return None  # Will trigger retry\n</code></pre>"},{"location":"getting-started/#wait-strategies","title":"Wait Strategies","text":"<p>Backoff provides several wait strategies:</p>"},{"location":"getting-started/#exponential-expo","title":"Exponential (expo)","text":"<pre><code>@backoff.on_exception(backoff.expo, Exception)\n</code></pre> <p>Wait times: 1s, 2s, 4s, 8s, 16s, ...</p>"},{"location":"getting-started/#fibonacci-fibo","title":"Fibonacci (fibo)","text":"<pre><code>@backoff.on_exception(backoff.fibo, Exception)\n</code></pre> <p>Wait times: 1s, 1s, 2s, 3s, 5s, 8s, 13s, ...</p>"},{"location":"getting-started/#constant","title":"Constant","text":"<pre><code>@backoff.on_exception(backoff.constant, Exception, interval=5)\n</code></pre> <p>Wait times: 5s, 5s, 5s, 5s, ...</p>"},{"location":"getting-started/#event-handlers","title":"Event Handlers","text":"<p>Track what's happening during retries:</p> <pre><code>def log_backoff(details):\n    print(f\"Backing off {details['wait']:.1f} seconds after {details['tries']} tries\")\n\ndef log_success(details):\n    print(f\"Success after {details['tries']} tries\")\n\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    on_backoff=log_backoff,\n    on_success=log_success,\n    max_tries=5\n)\ndef get_url(url):\n    return requests.get(url)\n</code></pre>"},{"location":"getting-started/#async-support","title":"Async Support","text":"<p>Backoff works seamlessly with async functions:</p> <pre><code>import aiohttp\n\n@backoff.on_exception(backoff.expo,\n                      aiohttp.ClientError,\n                      max_time=60)\nasync def get_url(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            return await response.text()\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Decorators Guide - Deep dive into decorators</li> <li>Wait Strategies - All available strategies</li> <li>Configuration - Advanced configuration options</li> <li>Examples - Real-world examples</li> </ul>"},{"location":"advanced/combining-decorators/","title":"Combining Decorators","text":"<p>Stack multiple backoff decorators for complex retry logic.</p>"},{"location":"advanced/combining-decorators/#basics","title":"Basics","text":"<p>Decorators are applied from bottom to top (inside out):</p> <pre><code>@backoff.on_predicate(backoff.fibo, lambda x: x is None)  # Applied last\n@backoff.on_exception(backoff.expo, HTTPError)             # Applied second\n@backoff.on_exception(backoff.expo, Timeout)               # Applied first\ndef complex_operation():\n    pass\n</code></pre>"},{"location":"advanced/combining-decorators/#common-patterns","title":"Common Patterns","text":""},{"location":"advanced/combining-decorators/#different-exceptions-different-strategies","title":"Different Exceptions, Different Strategies","text":"<pre><code>@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.Timeout,\n    max_time=300  # Generous timeout for network issues\n)\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.HTTPError,\n    max_time=60,  # Shorter timeout for HTTP errors\n    giveup=lambda e: 400 &lt;= e.response.status_code &lt; 500\n)\ndef api_call(url):\n    response = requests.get(url)\n    response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"advanced/combining-decorators/#exception-predicate","title":"Exception + Predicate","text":"<pre><code>@backoff.on_predicate(\n    backoff.constant,\n    lambda result: result.get(\"status\") == \"pending\",\n    interval=5,\n    max_time=600\n)\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    max_time=60\n)\ndef poll_until_ready(job_id):\n    response = requests.get(f\"/api/jobs/{job_id}\")\n    response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"advanced/combining-decorators/#execution-order","title":"Execution Order","text":"<p>Inner decorators execute first:</p> <pre><code>calls = []\n\ndef track_call(func_name):\n    def handler(details):\n        calls.append(func_name)\n    return handler\n\n@backoff.on_exception(\n    backoff.constant,\n    ValueError,\n    on_backoff=track_call('outer'),\n    max_tries=2,\n    interval=0.01\n)\n@backoff.on_exception(\n    backoff.constant,\n    TypeError,\n    on_backoff=track_call('inner'),\n    max_tries=2,\n    interval=0.01\n)\ndef failing_function(error_type):\n    raise error_type(\"Test\")\n</code></pre> <ul> <li>If <code>TypeError</code> raised: inner decorator retries</li> <li>If <code>ValueError</code> raised: outer decorator retries</li> <li>Both errors: inner handles TypeError, then outer handles ValueError</li> </ul>"},{"location":"advanced/combining-decorators/#best-practices","title":"Best Practices","text":""},{"location":"advanced/combining-decorators/#specific-before-general","title":"Specific Before General","text":"<pre><code>@backoff.on_exception(backoff.expo, Exception)  # Catch-all\n@backoff.on_exception(backoff.fibo, ConnectionError)  # Specific\ndef network_operation():\n    pass\n</code></pre>"},{"location":"advanced/combining-decorators/#short-timeouts-inside-long-outside","title":"Short Timeouts Inside, Long Outside","text":"<pre><code>@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    max_time=600  # Overall 10-minute limit\n)\n@backoff.on_exception(\n    backoff.constant,\n    Timeout,\n    interval=1,\n    max_tries=3  # Quick retries for timeouts\n)\ndef layered_retry():\n    pass\n</code></pre>"},{"location":"advanced/custom-strategies/","title":"Custom Wait Strategies","text":"<p>Create custom wait generators for specialized retry patterns.</p>"},{"location":"advanced/custom-strategies/#wait-generator-interface","title":"Wait Generator Interface","text":"<p>A wait generator is a function that yields wait times in seconds:</p> <pre><code>def my_wait_gen():\n    \"\"\"Yields: 1, 2, 3, 4, 5, 5, 5, ...\"\"\"\n    for i in range(1, 6):\n        yield i\n    while True:\n        yield 5\n\n@backoff.on_exception(my_wait_gen, Exception)\ndef my_function():\n    pass\n</code></pre>"},{"location":"advanced/custom-strategies/#parameters","title":"Parameters","text":"<p>Accept parameters to customize behavior:</p> <pre><code>def linear_backoff(start=1, increment=1, max_value=None):\n    \"\"\"Linear backoff: start, start+increment, start+2*increment, ...\"\"\"\n    value = start\n    while True:\n        if max_value and value &gt; max_value:\n            yield max_value\n        else:\n            yield value\n            value += increment\n\n@backoff.on_exception(\n    linear_backoff,\n    Exception,\n    start=2,\n    increment=3,\n    max_value=30\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"advanced/custom-strategies/#examples","title":"Examples","text":""},{"location":"advanced/custom-strategies/#polynomial-backoff","title":"Polynomial Backoff","text":"<pre><code>def polynomial_backoff(base=2, exponent=2, max_value=None):\n    \"\"\"Polynomial: base^(tries^exponent)\"\"\"\n    n = 1\n    while True:\n        value = base ** (n ** exponent)\n        if max_value and value &gt; max_value:\n            yield max_value\n        else:\n            yield value\n        n += 1\n\n@backoff.on_exception(polynomial_backoff, Exception, base=2, exponent=1.5)\n</code></pre>"},{"location":"advanced/custom-strategies/#stepped-backoff","title":"Stepped Backoff","text":"<pre><code>def stepped_backoff(steps):\n    \"\"\"Different wait times for different ranges\n    steps = [(3, 1), (5, 5), (None, 10)]  # 3 tries at 1s, next 5 at 5s, rest at 10s\n    \"\"\"\n    for max_tries, wait_time in steps:\n        if max_tries is None:\n            while True:\n                yield wait_time\n        else:\n            for _ in range(max_tries):\n                yield wait_time\n\n@backoff.on_exception(\n    stepped_backoff,\n    Exception,\n    steps=[(3, 1), (3, 5), (None, 30)]\n)\n</code></pre>"},{"location":"advanced/custom-strategies/#random-backoff","title":"Random Backoff","text":"<pre><code>import random\n\ndef random_backoff(min_wait=1, max_wait=60):\n    \"\"\"Random wait between min and max\"\"\"\n    while True:\n        yield random.uniform(min_wait, max_wait)\n\n@backoff.on_exception(random_backoff, Exception, min_wait=1, max_wait=10)\n</code></pre>"},{"location":"advanced/custom-strategies/#time-of-day-aware","title":"Time-of-Day Aware","text":"<pre><code>from datetime import datetime\n\ndef business_hours_backoff():\n    \"\"\"Shorter waits during business hours\"\"\"\n    while True:\n        hour = datetime.now().hour\n        if 9 &lt;= hour &lt; 17:\n            yield 5  # 5 seconds during business hours\n        else:\n            yield 60  # 1 minute otherwise\n\n@backoff.on_exception(business_hours_backoff, Exception)\n</code></pre>"},{"location":"advanced/runtime-config/","title":"Runtime Configuration","text":"<p>Configure backoff behavior dynamically at runtime.</p>"},{"location":"advanced/runtime-config/#overview","title":"Overview","text":"<p>Decorator parameters can accept callables that are evaluated at runtime, allowing dynamic configuration based on application state, environment variables, or configuration files.</p>"},{"location":"advanced/runtime-config/#basic-pattern","title":"Basic Pattern","text":"<pre><code>class Config:\n    MAX_RETRIES = 5\n    MAX_TIME = 60\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    max_tries=lambda: Config.MAX_RETRIES,\n    max_time=lambda: Config.MAX_TIME\n)\ndef configurable_function():\n    pass\n\n# Change configuration at runtime\nConfig.MAX_RETRIES = 10\n</code></pre>"},{"location":"advanced/runtime-config/#environment-variables","title":"Environment Variables","text":"<pre><code>import os\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    max_tries=lambda: int(os.getenv('RETRY_MAX_TRIES', '5')),\n    max_time=lambda: int(os.getenv('RETRY_MAX_TIME', '60'))\n)\ndef env_configured():\n    pass\n</code></pre>"},{"location":"advanced/runtime-config/#configuration-files","title":"Configuration Files","text":"<pre><code>import json\n\ndef load_config():\n    with open('config.json') as f:\n        return json.load(f)\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    max_tries=lambda: load_config()['retry']['max_tries'],\n    max_time=lambda: load_config()['retry']['max_time']\n)\ndef file_configured():\n    pass\n</code></pre>"},{"location":"advanced/runtime-config/#dynamic-wait-strategies","title":"Dynamic Wait Strategies","text":"<pre><code>def get_wait_gen():\n    if app.config.get('fast_retry'):\n        return backoff.constant\n    return backoff.expo\n\n@backoff.on_exception(\n    lambda: get_wait_gen(),\n    Exception\n)\ndef dynamic_wait():\n    pass\n</code></pre>"},{"location":"advanced/runtime-config/#application-state","title":"Application State","text":"<pre><code>class RateLimiter:\n    def __init__(self):\n        self.rate_limited = False\n\n    def get_interval(self):\n        return 10 if self.rate_limited else 1\n\nrate_limiter = RateLimiter()\n\n@backoff.on_predicate(\n    backoff.constant,\n    interval=lambda: rate_limiter.get_interval()\n)\ndef adaptive_poll():\n    return check_resource()\n</code></pre>"},{"location":"api/reference/","title":"API Reference","text":"<p>Complete API documentation for the backoff module.</p>"},{"location":"api/reference/#decorators","title":"Decorators","text":""},{"location":"api/reference/#on_exception","title":"on_exception","text":""},{"location":"api/reference/#backoff.on_exception","title":"<code>backoff.on_exception(wait_gen, exception, *, max_tries=None, max_time=None, jitter=full_jitter, giveup=lambda e: False, on_success=None, on_backoff=None, on_giveup=None, raise_on_giveup=True, logger='backoff', backoff_log_level=logging.INFO, giveup_log_level=logging.ERROR, **wait_gen_kwargs)</code>","text":"<p>Returns decorator for backoff and retry triggered by exception.</p> <p>Parameters:</p> Name Type Description Default <code>wait_gen</code> <code>_WaitGenerator</code> <p>A generator yielding successive wait times in seconds.</p> required <code>exception</code> <code>_MaybeSequence[Type[Exception]]</code> <p>An exception type (or tuple of types) which triggers backoff.</p> required <code>max_tries</code> <code>Optional[_MaybeCallable[int]]</code> <p>The maximum number of attempts to make before giving up. Once exhausted, the exception will be allowed to escape. The default value of None means there is no limit to the number of tries. If a callable is passed, it will be evaluated at runtime and its return value used.</p> <code>None</code> <code>max_time</code> <code>Optional[_MaybeCallable[float]]</code> <p>The maximum total amount of time to try for before giving up. Once expired, the exception will be allowed to escape. If a callable is passed, it will be evaluated at runtime and its return value used.</p> <code>None</code> <code>jitter</code> <code>Union[_Jitterer, None]</code> <p>A function of the value yielded by wait_gen returning the actual time to wait. This distributes wait times stochastically in order to avoid timing collisions across concurrent clients. Wait times are jittered by default using the full_jitter function. Jittering may be disabled altogether by passing jitter=None.</p> <code>full_jitter</code> <code>giveup</code> <code>_Predicate[Exception]</code> <p>Function accepting an exception instance and returning whether or not to give up. Optional. The default is to always continue.</p> <code>lambda e: False</code> <code>on_success</code> <code>Union[_Handler, Iterable[_Handler], None]</code> <p>Callable (or iterable of callables) with a unary signature to be called in the event of success. The parameter is a dict containing details about the invocation.</p> <code>None</code> <code>on_backoff</code> <code>Union[_Handler, Iterable[_Handler], None]</code> <p>Callable (or iterable of callables) with a unary signature to be called in the event of a backoff. The parameter is a dict containing details about the invocation.</p> <code>None</code> <code>on_giveup</code> <code>Union[_Handler, Iterable[_Handler], None]</code> <p>Callable (or iterable of callables) with a unary signature to be called in the event that max_tries is exceeded.  The parameter is a dict containing details about the invocation.</p> <code>None</code> <code>raise_on_giveup</code> <code>bool</code> <p>Boolean indicating whether the registered exceptions should be raised on giveup. Defaults to <code>True</code></p> <code>True</code> <code>logger</code> <code>_MaybeLogger</code> <p>Name or Logger object to log to. Defaults to 'backoff'.</p> <code>'backoff'</code> <code>backoff_log_level</code> <code>int</code> <p>log level for the backoff event. Defaults to \"INFO\"</p> <code>INFO</code> <code>giveup_log_level</code> <code>int</code> <p>log level for the give up event. Defaults to \"ERROR\"</p> <code>ERROR</code> <code>**wait_gen_kwargs</code> <code>Any</code> <p>Any additional keyword args specified will be passed to wait_gen when it is initialized.  Any callable args will first be evaluated and their return values passed. This is useful for runtime configuration.</p> <code>{}</code> Source code in <code>backoff/_decorator.py</code> <pre><code>def on_exception(wait_gen: _WaitGenerator,\n                 exception: _MaybeSequence[Type[Exception]],\n                 *,\n                 max_tries: Optional[_MaybeCallable[int]] = None,\n                 max_time: Optional[_MaybeCallable[float]] = None,\n                 jitter: Union[_Jitterer, None] = full_jitter,\n                 giveup: _Predicate[Exception] = lambda e: False,\n                 on_success: Union[_Handler, Iterable[_Handler], None] = None,\n                 on_backoff: Union[_Handler, Iterable[_Handler], None] = None,\n                 on_giveup: Union[_Handler, Iterable[_Handler], None] = None,\n                 raise_on_giveup: bool = True,\n                 logger: _MaybeLogger = 'backoff',\n                 backoff_log_level: int = logging.INFO,\n                 giveup_log_level: int = logging.ERROR,\n                 **wait_gen_kwargs: Any) -&gt; Callable[[_CallableT], _CallableT]:\n    \"\"\"Returns decorator for backoff and retry triggered by exception.\n\n    Args:\n        wait_gen: A generator yielding successive wait times in\n            seconds.\n        exception: An exception type (or tuple of types) which triggers\n            backoff.\n        max_tries: The maximum number of attempts to make before giving\n            up. Once exhausted, the exception will be allowed to escape.\n            The default value of None means there is no limit to the\n            number of tries. If a callable is passed, it will be\n            evaluated at runtime and its return value used.\n        max_time: The maximum total amount of time to try for before\n            giving up. Once expired, the exception will be allowed to\n            escape. If a callable is passed, it will be\n            evaluated at runtime and its return value used.\n        jitter: A function of the value yielded by wait_gen returning\n            the actual time to wait. This distributes wait times\n            stochastically in order to avoid timing collisions across\n            concurrent clients. Wait times are jittered by default\n            using the full_jitter function. Jittering may be disabled\n            altogether by passing jitter=None.\n        giveup: Function accepting an exception instance and\n            returning whether or not to give up. Optional. The default\n            is to always continue.\n        on_success: Callable (or iterable of callables) with a unary\n            signature to be called in the event of success. The\n            parameter is a dict containing details about the invocation.\n        on_backoff: Callable (or iterable of callables) with a unary\n            signature to be called in the event of a backoff. The\n            parameter is a dict containing details about the invocation.\n        on_giveup: Callable (or iterable of callables) with a unary\n            signature to be called in the event that max_tries\n            is exceeded.  The parameter is a dict containing details\n            about the invocation.\n        raise_on_giveup: Boolean indicating whether the registered exceptions\n            should be raised on giveup. Defaults to `True`\n        logger: Name or Logger object to log to. Defaults to 'backoff'.\n        backoff_log_level: log level for the backoff event. Defaults to \"INFO\"\n        giveup_log_level: log level for the give up event. Defaults to \"ERROR\"\n        **wait_gen_kwargs: Any additional keyword args specified will be\n            passed to wait_gen when it is initialized.  Any callable\n            args will first be evaluated and their return values passed.\n            This is useful for runtime configuration.\n    \"\"\"\n    def decorate(target):\n        nonlocal logger, on_success, on_backoff, on_giveup\n\n        logger = _prepare_logger(logger)\n        on_success = _config_handlers(on_success)\n        on_backoff = _config_handlers(\n            on_backoff,\n            default_handler=_log_backoff,\n            logger=logger,\n            log_level=backoff_log_level,\n        )\n        on_giveup = _config_handlers(\n            on_giveup,\n            default_handler=_log_giveup,\n            logger=logger,\n            log_level=giveup_log_level,\n        )\n\n        if inspect.iscoroutinefunction(target):\n            retry = _async.retry_exception\n        else:\n            retry = _sync.retry_exception\n\n        return retry(\n            target,\n            wait_gen,\n            exception,\n            max_tries=max_tries,\n            max_time=max_time,\n            jitter=jitter,\n            giveup=giveup,\n            on_success=on_success,\n            on_backoff=on_backoff,\n            on_giveup=on_giveup,\n            raise_on_giveup=raise_on_giveup,\n            wait_gen_kwargs=wait_gen_kwargs\n        )\n\n    # Return a function which decorates a target with a retry loop.\n    return decorate\n</code></pre>"},{"location":"api/reference/#on_predicate","title":"on_predicate","text":""},{"location":"api/reference/#backoff.on_predicate","title":"<code>backoff.on_predicate(wait_gen, predicate=operator.not_, *, max_tries=None, max_time=None, jitter=full_jitter, on_success=None, on_backoff=None, on_giveup=None, logger='backoff', backoff_log_level=logging.INFO, giveup_log_level=logging.ERROR, **wait_gen_kwargs)</code>","text":"<p>Returns decorator for backoff and retry triggered by predicate.</p> <p>Parameters:</p> Name Type Description Default <code>wait_gen</code> <code>_WaitGenerator</code> <p>A generator yielding successive wait times in seconds.</p> required <code>predicate</code> <code>_Predicate[Any]</code> <p>A function which when called on the return value of the target function will trigger backoff when considered truthily. If not specified, the default behavior is to backoff on falsey return values.</p> <code>not_</code> <code>max_tries</code> <code>Optional[_MaybeCallable[int]]</code> <p>The maximum number of attempts to make before giving up. In the case of failure, the result of the last attempt will be returned. The default value of None means there is no limit to the number of tries. If a callable is passed, it will be evaluated at runtime and its return value used.</p> <code>None</code> <code>max_time</code> <code>Optional[_MaybeCallable[float]]</code> <p>The maximum total amount of time in seconds to try for before giving up. If this time expires, the result of the last attempt will be returned. If a callable is passed, it will be evaluated at runtime and its return value used.</p> <code>None</code> <code>jitter</code> <code>Union[_Jitterer, None]</code> <p>A function of the value yielded by wait_gen returning the actual time to wait. This distributes wait times stochastically in order to avoid timing collisions across concurrent clients. Wait times are jittered by default using the full_jitter function. Jittering may be disabled altogether by passing jitter=None.</p> <code>full_jitter</code> <code>on_success</code> <code>Union[_Handler, Iterable[_Handler], None]</code> <p>Callable (or iterable of callables) with a unary signature to be called in the event of success. The parameter is a dict containing details about the invocation.</p> <code>None</code> <code>on_backoff</code> <code>Union[_Handler, Iterable[_Handler], None]</code> <p>Callable (or iterable of callables) with a unary signature to be called in the event of a backoff. The parameter is a dict containing details about the invocation.</p> <code>None</code> <code>on_giveup</code> <code>Union[_Handler, Iterable[_Handler], None]</code> <p>Callable (or iterable of callables) with a unary signature to be called in the event that max_tries is exceeded.  The parameter is a dict containing details about the invocation.</p> <code>None</code> <code>logger</code> <code>_MaybeLogger</code> <p>Name of logger or Logger object to log to. Defaults to 'backoff'.</p> <code>'backoff'</code> <code>backoff_log_level</code> <code>int</code> <p>log level for the backoff event. Defaults to \"INFO\"</p> <code>INFO</code> <code>giveup_log_level</code> <code>int</code> <p>log level for the give up event. Defaults to \"ERROR\"</p> <code>ERROR</code> <code>**wait_gen_kwargs</code> <code>Any</code> <p>Any additional keyword args specified will be passed to wait_gen when it is initialized.  Any callable args will first be evaluated and their return values passed. This is useful for runtime configuration.</p> <code>{}</code> Source code in <code>backoff/_decorator.py</code> <pre><code>def on_predicate(wait_gen: _WaitGenerator,\n                 predicate: _Predicate[Any] = operator.not_,\n                 *,\n                 max_tries: Optional[_MaybeCallable[int]] = None,\n                 max_time: Optional[_MaybeCallable[float]] = None,\n                 jitter: Union[_Jitterer, None] = full_jitter,\n                 on_success: Union[_Handler, Iterable[_Handler], None] = None,\n                 on_backoff: Union[_Handler, Iterable[_Handler], None] = None,\n                 on_giveup: Union[_Handler, Iterable[_Handler], None] = None,\n                 logger: _MaybeLogger = 'backoff',\n                 backoff_log_level: int = logging.INFO,\n                 giveup_log_level: int = logging.ERROR,\n                 **wait_gen_kwargs: Any) -&gt; Callable[[_CallableT], _CallableT]:\n    \"\"\"Returns decorator for backoff and retry triggered by predicate.\n\n    Args:\n        wait_gen: A generator yielding successive wait times in\n            seconds.\n        predicate: A function which when called on the return value of\n            the target function will trigger backoff when considered\n            truthily. If not specified, the default behavior is to\n            backoff on falsey return values.\n        max_tries: The maximum number of attempts to make before giving\n            up. In the case of failure, the result of the last attempt\n            will be returned. The default value of None means there\n            is no limit to the number of tries. If a callable is passed,\n            it will be evaluated at runtime and its return value used.\n        max_time: The maximum total amount of time in seconds to try for before\n            giving up. If this time expires, the result of the last\n            attempt will be returned. If a callable is passed, it will\n            be evaluated at runtime and its return value used.\n        jitter: A function of the value yielded by wait_gen returning\n            the actual time to wait. This distributes wait times\n            stochastically in order to avoid timing collisions across\n            concurrent clients. Wait times are jittered by default\n            using the full_jitter function. Jittering may be disabled\n            altogether by passing jitter=None.\n        on_success: Callable (or iterable of callables) with a unary\n            signature to be called in the event of success. The\n            parameter is a dict containing details about the invocation.\n        on_backoff: Callable (or iterable of callables) with a unary\n            signature to be called in the event of a backoff. The\n            parameter is a dict containing details about the invocation.\n        on_giveup: Callable (or iterable of callables) with a unary\n            signature to be called in the event that max_tries\n            is exceeded.  The parameter is a dict containing details\n            about the invocation.\n        logger: Name of logger or Logger object to log to. Defaults to\n            'backoff'.\n        backoff_log_level: log level for the backoff event. Defaults to \"INFO\"\n        giveup_log_level: log level for the give up event. Defaults to \"ERROR\"\n        **wait_gen_kwargs: Any additional keyword args specified will be\n            passed to wait_gen when it is initialized.  Any callable\n            args will first be evaluated and their return values passed.\n            This is useful for runtime configuration.\n    \"\"\"\n    def decorate(target):\n        nonlocal logger, on_success, on_backoff, on_giveup\n\n        logger = _prepare_logger(logger)\n        on_success = _config_handlers(on_success)\n        on_backoff = _config_handlers(\n            on_backoff,\n            default_handler=_log_backoff,\n            logger=logger,\n            log_level=backoff_log_level\n        )\n        on_giveup = _config_handlers(\n            on_giveup,\n            default_handler=_log_giveup,\n            logger=logger,\n            log_level=giveup_log_level\n        )\n\n        if inspect.iscoroutinefunction(target):\n            retry = _async.retry_predicate\n        else:\n            retry = _sync.retry_predicate\n\n        return retry(\n            target,\n            wait_gen,\n            predicate,\n            max_tries=max_tries,\n            max_time=max_time,\n            jitter=jitter,\n            on_success=on_success,\n            on_backoff=on_backoff,\n            on_giveup=on_giveup,\n            wait_gen_kwargs=wait_gen_kwargs\n        )\n\n    # Return a function which decorates a target with a retry loop.\n    return decorate\n</code></pre>"},{"location":"api/reference/#wait-generators","title":"Wait Generators","text":""},{"location":"api/reference/#expo","title":"expo","text":""},{"location":"api/reference/#backoff.expo","title":"<code>backoff.expo(base=2, factor=1, max_value=None)</code>","text":"<p>Generator for exponential decay.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>float</code> <p>The mathematical base of the exponentiation operation</p> <code>2</code> <code>factor</code> <code>float</code> <p>Factor to multiply the exponentiation by.</p> <code>1</code> <code>max_value</code> <code>Optional[float]</code> <p>The maximum value to yield. Once the value in the  true exponential sequence exceeds this, the value  of max_value will forever after be yielded.</p> <code>None</code> Source code in <code>backoff/_wait_gen.py</code> <pre><code>def expo(\n    base: float = 2,\n    factor: float = 1,\n    max_value: Optional[float] = None\n) -&gt; Generator[float, Any, None]:\n\n    \"\"\"Generator for exponential decay.\n\n    Args:\n        base: The mathematical base of the exponentiation operation\n        factor: Factor to multiply the exponentiation by.\n        max_value: The maximum value to yield. Once the value in the\n             true exponential sequence exceeds this, the value\n             of max_value will forever after be yielded.\n    \"\"\"\n    # Advance past initial .send() call\n    yield  # type: ignore[misc]\n    n = 0\n    while True:\n        a = factor * base ** n\n        if max_value is None or a &lt; max_value:\n            yield a\n            n += 1\n        else:\n            yield max_value\n</code></pre>"},{"location":"api/reference/#fibo","title":"fibo","text":""},{"location":"api/reference/#backoff.fibo","title":"<code>backoff.fibo(max_value=None)</code>","text":"<p>Generator for fibonaccial decay.</p> <p>Parameters:</p> Name Type Description Default <code>max_value</code> <code>Optional[int]</code> <p>The maximum value to yield. Once the value in the  true fibonacci sequence exceeds this, the value  of max_value will forever after be yielded.</p> <code>None</code> Source code in <code>backoff/_wait_gen.py</code> <pre><code>def fibo(max_value: Optional[int] = None) -&gt; Generator[int, None, None]:\n    \"\"\"Generator for fibonaccial decay.\n\n    Args:\n        max_value: The maximum value to yield. Once the value in the\n             true fibonacci sequence exceeds this, the value\n             of max_value will forever after be yielded.\n    \"\"\"\n    # Advance past initial .send() call\n    yield  # type: ignore[misc]\n\n    a = 1\n    b = 1\n    while True:\n        if max_value is None or a &lt; max_value:\n            yield a\n            a, b = b, a + b\n        else:\n            yield max_value\n</code></pre>"},{"location":"api/reference/#constant","title":"constant","text":""},{"location":"api/reference/#backoff.constant","title":"<code>backoff.constant(interval=1)</code>","text":"<p>Generator for constant intervals.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>Union[int, Iterable[float]]</code> <p>A constant value to yield or an iterable of such values.</p> <code>1</code> Source code in <code>backoff/_wait_gen.py</code> <pre><code>def constant(\n    interval: Union[int, Iterable[float]] = 1\n) -&gt; Generator[float, None, None]:\n    \"\"\"Generator for constant intervals.\n\n    Args:\n        interval: A constant value to yield or an iterable of such values.\n    \"\"\"\n    # Advance past initial .send() call\n    yield  # type: ignore[misc]\n\n    try:\n        itr = iter(interval)  # type: ignore\n    except TypeError:\n        itr = itertools.repeat(interval)  # type: ignore\n\n    for val in itr:\n        yield val\n</code></pre>"},{"location":"api/reference/#runtime","title":"runtime","text":""},{"location":"api/reference/#backoff.runtime","title":"<code>backoff.runtime(*, value)</code>","text":"<p>Generator that is based on parsing the return value or thrown     exception of the decorated method</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Callable[[Any], float]</code> <p>a callable which takes as input the decorated function's return value or thrown exception and determines how long to wait</p> required Source code in <code>backoff/_wait_gen.py</code> <pre><code>def runtime(\n    *,\n    value: Callable[[Any], float]\n) -&gt; Generator[float, None, None]:\n    \"\"\"Generator that is based on parsing the return value or thrown\n        exception of the decorated method\n\n    Args:\n        value: a callable which takes as input the decorated\n            function's return value or thrown exception and\n            determines how long to wait\n    \"\"\"\n    ret_or_exc = yield  # type: ignore[misc]\n    while True:\n        ret_or_exc = yield value(ret_or_exc)\n</code></pre>"},{"location":"api/reference/#jitter-functions","title":"Jitter Functions","text":""},{"location":"api/reference/#full_jitter","title":"full_jitter","text":""},{"location":"api/reference/#backoff.full_jitter","title":"<code>backoff.full_jitter(value)</code>","text":"<p>Jitter the value across the full range (0 to value).</p> <p>This corresponds to the \"Full Jitter\" algorithm specified in the AWS blog's post on the performance of various jitter algorithms. (http://www.awsarchitectureblog.com/2015/03/backoff.html)</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The unadulterated backoff value.</p> required Source code in <code>backoff/_jitter.py</code> <pre><code>def full_jitter(value: float) -&gt; float:\n    \"\"\"Jitter the value across the full range (0 to value).\n\n    This corresponds to the \"Full Jitter\" algorithm specified in the\n    AWS blog's post on the performance of various jitter algorithms.\n    (http://www.awsarchitectureblog.com/2015/03/backoff.html)\n\n    Args:\n        value: The unadulterated backoff value.\n    \"\"\"\n    return random.uniform(0, value)\n</code></pre>"},{"location":"api/reference/#random_jitter","title":"random_jitter","text":""},{"location":"api/reference/#backoff.random_jitter","title":"<code>backoff.random_jitter(value)</code>","text":"<p>Jitter the value a random number of milliseconds.</p> <p>This adds up to 1 second of additional time to the original value. Prior to backoff version 1.2 this was the default jitter behavior.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The unadulterated backoff value.</p> required Source code in <code>backoff/_jitter.py</code> <pre><code>def random_jitter(value: float) -&gt; float:\n    \"\"\"Jitter the value a random number of milliseconds.\n\n    This adds up to 1 second of additional time to the original value.\n    Prior to backoff version 1.2 this was the default jitter behavior.\n\n    Args:\n        value: The unadulterated backoff value.\n    \"\"\"\n    return value + random.random()\n</code></pre>"},{"location":"api/reference/#type-definitions","title":"Type Definitions","text":""},{"location":"api/reference/#backoff.types","title":"<code>backoff.types</code>","text":""},{"location":"api/reference/#backoff.types.__all__","title":"<code>__all__ = ['Details']</code>  <code>module-attribute</code>","text":""},{"location":"api/reference/#backoff.types.Details","title":"<code>Details</code>","text":"<p>               Bases: <code>_Details</code></p> Source code in <code>backoff/_typing.py</code> <pre><code>class Details(_Details, total=False):\n    wait: float  # present in the on_backoff handler case for either decorator\n    value: Any  # present in the on_predicate decorator case\n    exception: Exception  # present in the on_exception decorator case\n</code></pre>"},{"location":"user-guide/async/","title":"Async Support","text":"<p>Backoff fully supports Python's <code>async</code>/<code>await</code> syntax for asynchronous code.</p>"},{"location":"user-guide/async/#basic-usage","title":"Basic Usage","text":"<p>Simply decorate async functions with the same decorators:</p> <pre><code>import backoff\nimport aiohttp\n\n@backoff.on_exception(backoff.expo, aiohttp.ClientError)\nasync def fetch_data(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            return await response.json()\n</code></pre>"},{"location":"user-guide/async/#async-event-handlers","title":"Async Event Handlers","text":"<p>Event handlers can be async when used with async functions:</p> <pre><code>async def async_log_retry(details):\n    await log_service.log(\n        f\"Retry {details['tries']} after {details['elapsed']:.1f}s\"\n    )\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=async_log_retry\n)\nasync def async_operation():\n    pass\n</code></pre>"},{"location":"user-guide/async/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/async/#http-client","title":"HTTP Client","text":"<pre><code>@backoff.on_exception(\n    backoff.expo,\n    aiohttp.ClientError,\n    max_time=60\n)\nasync def get_url(url):\n    async with aiohttp.ClientSession(raise_for_status=True) as session:\n        async with session.get(url) as response:\n            return await response.text()\n</code></pre>"},{"location":"user-guide/async/#database-operations","title":"Database Operations","text":"<pre><code>import asyncpg\n\n@backoff.on_exception(\n    backoff.expo,\n    asyncpg.PostgresError,\n    max_tries=5\n)\nasync def query_database(pool, query):\n    async with pool.acquire() as conn:\n        return await conn.fetch(query)\n</code></pre>"},{"location":"user-guide/async/#concurrent-requests","title":"Concurrent Requests","text":"<pre><code>import asyncio\n\n@backoff.on_exception(backoff.expo, aiohttp.ClientError, max_tries=3)\nasync def fetch_one(session, url):\n    async with session.get(url) as response:\n        return await response.json()\n\nasync def fetch_all(urls):\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_one(session, url) for url in urls]\n        return await asyncio.gather(*tasks, return_exceptions=True)\n</code></pre>"},{"location":"user-guide/async/#on_predicate-with-async","title":"on_predicate with Async","text":"<pre><code>@backoff.on_predicate(\n    backoff.constant,\n    lambda result: result[\"status\"] != \"complete\",\n    interval=5,\n    max_time=300\n)\nasync def poll_job_status(job_id):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"/api/jobs/{job_id}\") as response:\n            return await response.json()\n</code></pre>"},{"location":"user-guide/async/#mixing-sync-and-async","title":"Mixing Sync and Async","text":"<p>Sync handlers work with async functions:</p> <pre><code>def sync_log(details):\n    print(f\"Retry {details['tries']}\")\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=sync_log  # Sync handler with async function\n)\nasync def async_function():\n    pass\n</code></pre> <p>But async handlers only work with async functions:</p> <pre><code>async def async_log(details):\n    await log_to_service(details)\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=async_log  # Must be used with async function\n)\nasync def async_function():\n    pass\n</code></pre>"},{"location":"user-guide/async/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nimport aiohttp\nimport backoff\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nasync def log_async_retry(details):\n    logger.warning(\n        f\"Async retry {details['tries']}: \"\n        f\"wait={details['wait']:.1f}s, \"\n        f\"elapsed={details['elapsed']:.1f}s\"\n    )\n\n@backoff.on_exception(\n    backoff.expo,\n    (aiohttp.ClientError, asyncio.TimeoutError),\n    max_tries=5,\n    max_time=60,\n    on_backoff=log_async_retry\n)\nasync def robust_fetch(url, timeout=10):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url, timeout=timeout) as response:\n            response.raise_for_status()\n            return await response.json()\n\n# Usage\nasync def main():\n    result = await robust_fetch(\"https://api.example.com/data\")\n    print(result)\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/configuration/","title":"Configuration","text":"<p>Complete guide to configuring backoff decorators.</p>"},{"location":"user-guide/configuration/#retry-limits","title":"Retry Limits","text":""},{"location":"user-guide/configuration/#max_tries","title":"max_tries","text":"<p>Maximum number of function call attempts.</p> <pre><code>@backoff.on_exception(backoff.expo, Exception, max_tries=5)\ndef my_function():\n    pass\n</code></pre> <ul> <li>First call counts as try #1</li> <li>Will make up to 5 total attempts</li> <li>After 5 failures, gives up and raises exception</li> </ul>"},{"location":"user-guide/configuration/#max_time","title":"max_time","text":"<p>Maximum total elapsed time in seconds.</p> <pre><code>@backoff.on_exception(backoff.expo, Exception, max_time=60)\ndef my_function():\n    pass\n</code></pre> <ul> <li>Tracks total time from first attempt</li> <li>Gives up when time limit is reached</li> <li>Useful for time-sensitive operations</li> </ul>"},{"location":"user-guide/configuration/#combining-limits","title":"Combining Limits","text":"<p>Use both to create flexible retry policies:</p> <pre><code>@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    max_tries=10,\n    max_time=300\n)\ndef my_function():\n    pass\n</code></pre> <p>Stops when either condition is met.</p>"},{"location":"user-guide/configuration/#runtime-configuration","title":"Runtime Configuration","text":"<p>Pass callables instead of constants for dynamic configuration:</p> <pre><code>class Config:\n    MAX_RETRIES = 5\n    MAX_TIME = 60\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    max_tries=lambda: Config.MAX_RETRIES,\n    max_time=lambda: Config.MAX_TIME\n)\ndef configurable_function():\n    pass\n\n# Can change at runtime\nConfig.MAX_RETRIES = 10\n</code></pre>"},{"location":"user-guide/configuration/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>import os\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    max_tries=lambda: int(os.getenv('MAX_RETRIES', '5')),\n    max_time=lambda: int(os.getenv('MAX_TIME', '60'))\n)\ndef env_configured():\n    pass\n</code></pre>"},{"location":"user-guide/configuration/#wait-generator-configuration","title":"Wait Generator Configuration","text":"<p>Each wait strategy accepts different parameters.</p>"},{"location":"user-guide/configuration/#exponential-parameters","title":"Exponential Parameters","text":"<pre><code>@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    base=2,        # Base wait time\n    factor=2,      # Multiplication factor\n    max_value=60   # Maximum wait time\n)\ndef expo_config():\n    pass\n</code></pre>"},{"location":"user-guide/configuration/#fibonacci-parameters","title":"Fibonacci Parameters","text":"<pre><code>@backoff.on_exception(\n    backoff.fibo,\n    Exception,\n    max_value=30   # Maximum wait time\n)\ndef fibo_config():\n    pass\n</code></pre>"},{"location":"user-guide/configuration/#constant-parameters","title":"Constant Parameters","text":"<pre><code>@backoff.on_exception(\n    backoff.constant,\n    Exception,\n    interval=5     # Fixed interval in seconds\n)\ndef constant_config():\n    pass\n</code></pre>"},{"location":"user-guide/configuration/#runtime-parameters","title":"Runtime Parameters","text":"<pre><code>@backoff.on_predicate(\n    backoff.runtime,\n    predicate=lambda r: r.status_code == 429,\n    value=lambda r: int(r.headers.get(\"Retry-After\", 1))\n)\ndef runtime_config():\n    return requests.get(url)\n</code></pre>"},{"location":"user-guide/configuration/#jitter-configuration","title":"Jitter Configuration","text":"<p>Control randomization of wait times.</p>"},{"location":"user-guide/configuration/#full-jitter-default","title":"Full Jitter (Default)","text":"<pre><code>@backoff.on_exception(backoff.expo, Exception)\n# Same as:\n@backoff.on_exception(backoff.expo, Exception, jitter=backoff.full_jitter)\n</code></pre> <p>Wait time is random between 0 and calculated value.</p>"},{"location":"user-guide/configuration/#random-jitter","title":"Random Jitter","text":"<pre><code>@backoff.on_exception(backoff.expo, Exception, jitter=backoff.random_jitter)\n</code></pre> <p>Adds 0-1000ms to calculated value.</p>"},{"location":"user-guide/configuration/#no-jitter","title":"No Jitter","text":"<pre><code>@backoff.on_exception(backoff.expo, Exception, jitter=None)\n</code></pre> <p>Exact wait times, no randomization.</p>"},{"location":"user-guide/configuration/#custom-jitter","title":"Custom Jitter","text":"<pre><code>import random\n\ndef custom_jitter(value):\n    return value * random.uniform(0.8, 1.2)\n\n@backoff.on_exception(backoff.expo, Exception, jitter=custom_jitter)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/configuration/#give-up-conditions","title":"Give-Up Conditions","text":""},{"location":"user-guide/configuration/#basic-giveup","title":"Basic giveup","text":"<pre><code>def should_giveup(e):\n    return isinstance(e, ValueError)\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    giveup=should_giveup\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/configuration/#http-status-code-conditions","title":"HTTP Status Code Conditions","text":"<pre><code>def fatal_error(e):\n    if hasattr(e, 'response'):\n        status = e.response.status_code\n        # Don't retry client errors except rate limiting\n        return 400 &lt;= status &lt; 500 and status != 429\n    return False\n\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    giveup=fatal_error\n)\ndef api_call():\n    pass\n</code></pre>"},{"location":"user-guide/configuration/#multiple-conditions","title":"Multiple Conditions","text":"<pre><code>def complex_giveup(e):\n    # Give up on authentication errors\n    if \"authentication\" in str(e).lower():\n        return True\n\n    # Give up on 4xx except 429\n    if hasattr(e, 'response'):\n        status = e.response.status_code\n        if 400 &lt;= status &lt; 500 and status != 429:\n            return True\n\n    return False\n</code></pre>"},{"location":"user-guide/configuration/#raise_on_giveup","title":"raise_on_giveup","text":"<p>Control whether to raise exception when giving up:</p> <pre><code># Default: raises exception\n@backoff.on_exception(backoff.expo, Exception, max_tries=3)\ndef raises_on_failure():\n    pass\n\n# Returns None instead\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    max_tries=3,\n    raise_on_giveup=False\n)\ndef returns_none_on_failure():\n    pass\n</code></pre>"},{"location":"user-guide/configuration/#predicate-configuration","title":"Predicate Configuration","text":"<p>For <code>on_predicate</code> decorator.</p>"},{"location":"user-guide/configuration/#default-predicate-falsey-check","title":"Default Predicate (Falsey Check)","text":"<pre><code>@backoff.on_predicate(backoff.constant, interval=2)\ndef wait_for_truthy():\n    return get_result() or None\n</code></pre>"},{"location":"user-guide/configuration/#custom-predicate","title":"Custom Predicate","text":"<pre><code>def needs_retry(result):\n    return result.get(\"status\") == \"pending\"\n\n@backoff.on_predicate(backoff.expo, needs_retry, max_time=300)\ndef poll_status():\n    return api.get_status()\n</code></pre>"},{"location":"user-guide/configuration/#multiple-conditions_1","title":"Multiple Conditions","text":"<pre><code>def should_retry(result):\n    if result is None:\n        return True\n    if not result.get(\"ready\"):\n        return True\n    if result.get(\"status\") == \"processing\":\n        return True\n    return False\n\n@backoff.on_predicate(backoff.fibo, should_retry, max_value=60)\ndef complex_poll():\n    return get_resource()\n</code></pre>"},{"location":"user-guide/configuration/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/#api-calls","title":"API Calls","text":"<pre><code>@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    max_tries=5,\n    max_time=60,\n    giveup=lambda e: 400 &lt;= getattr(e.response, 'status_code', 500) &lt; 500\n)\ndef api_request():\n    pass\n</code></pre>"},{"location":"user-guide/configuration/#database-operations","title":"Database Operations","text":"<pre><code>@backoff.on_exception(\n    backoff.expo,\n    sqlalchemy.exc.OperationalError,\n    max_tries=3,\n    max_time=30\n)\ndef db_query():\n    pass\n</code></pre>"},{"location":"user-guide/configuration/#polling","title":"Polling","text":"<pre><code>@backoff.on_predicate(\n    backoff.constant,\n    lambda result: result[\"status\"] != \"complete\",\n    interval=5,\n    jitter=None,\n    max_time=600\n)\ndef poll_job():\n    return check_job_status()\n</code></pre>"},{"location":"user-guide/configuration/#long-running-operations","title":"Long-Running Operations","text":"<pre><code>@backoff.on_predicate(\n    backoff.fibo,\n    lambda result: not result.is_ready(),\n    max_value=60,\n    max_time=3600  # 1 hour\n)\ndef wait_for_completion():\n    return check_operation()\n</code></pre>"},{"location":"user-guide/decorators/","title":"Decorators","text":"<p>Detailed guide to backoff decorators.</p>"},{"location":"user-guide/decorators/#on_exception","title":"on_exception","text":"<p>The <code>on_exception</code> decorator retries a function when a specified exception is raised.</p>"},{"location":"user-guide/decorators/#basic-usage","title":"Basic Usage","text":"<pre><code>import backoff\nimport requests\n\n@backoff.on_exception(backoff.expo,\n                      requests.exceptions.RequestException)\ndef get_url(url):\n    return requests.get(url)\n</code></pre>"},{"location":"user-guide/decorators/#parameters","title":"Parameters","text":"<ul> <li>wait_gen - Wait strategy generator (expo, fibo, constant, runtime)</li> <li>exception - Exception class or tuple of exception classes to catch</li> <li>max_tries - Maximum number of attempts (default: None = unlimited)</li> <li>max_time - Maximum total time in seconds (default: None = unlimited)</li> <li>jitter - Jitter function to add randomness (default: full_jitter)</li> <li>giveup - Function to determine if exception is non-retryable</li> <li>on_success - Callback when function succeeds</li> <li>on_backoff - Callback when backing off</li> <li>on_giveup - Callback when giving up</li> <li>raise_on_giveup - Whether to raise exception on giveup (default: True)</li> <li>logger - Logger for retry events (default: 'backoff' logger)</li> </ul>"},{"location":"user-guide/decorators/#multiple-exceptions","title":"Multiple Exceptions","text":"<p>Handle different exceptions with the same backoff:</p> <pre><code>@backoff.on_exception(\n    backoff.expo,\n    (requests.exceptions.Timeout,\n     requests.exceptions.ConnectionError,\n     requests.exceptions.HTTPError)\n)\ndef make_request(url):\n    return requests.get(url)\n</code></pre>"},{"location":"user-guide/decorators/#conditional-giveup","title":"Conditional Giveup","text":"<p>Customize when to stop retrying:</p> <pre><code>def is_fatal(e):\n    \"\"\"Don't retry on client errors\"\"\"\n    if hasattr(e, 'response') and e.response is not None:\n        return 400 &lt;= e.response.status_code &lt; 500\n    return False\n\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    giveup=is_fatal,\n    max_time=300\n)\ndef api_call(endpoint):\n    response = requests.get(endpoint)\n    response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"user-guide/decorators/#suppress-exceptions-on-giveup","title":"Suppress Exceptions on Giveup","text":"<p>Return None instead of raising when all retries are exhausted:</p> <pre><code>@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    max_tries=5,\n    raise_on_giveup=False\n)\ndef optional_request(url):\n    return requests.get(url)\n\n# Returns None if all retries fail\nresult = optional_request(\"https://example.com\")\n</code></pre>"},{"location":"user-guide/decorators/#on_predicate","title":"on_predicate","text":"<p>The <code>on_predicate</code> decorator retries when a condition is true about the return value.</p>"},{"location":"user-guide/decorators/#basic-usage_1","title":"Basic Usage","text":"<pre><code>@backoff.on_predicate(backoff.fibo,\n                      lambda x: x is None,\n                      max_value=13)\ndef poll_for_result(job_id):\n    result = check_job(job_id)\n    return result if result else None\n</code></pre>"},{"location":"user-guide/decorators/#parameters_1","title":"Parameters","text":"<ul> <li>wait_gen - Wait strategy generator (expo, fibo, constant, runtime)</li> <li>predicate - Function that returns True if retry is needed (default: falsey check)</li> <li>max_tries - Maximum number of attempts (default: None = unlimited)</li> <li>max_time - Maximum total time in seconds (default: None = unlimited)</li> <li>jitter - Jitter function to add randomness (default: full_jitter)</li> <li>on_success - Callback when predicate returns False</li> <li>on_backoff - Callback when predicate returns True</li> <li>on_giveup - Callback when giving up</li> <li>logger - Logger for retry events (default: 'backoff' logger)</li> </ul>"},{"location":"user-guide/decorators/#default-predicate-falsey-check","title":"Default Predicate (Falsey Check)","text":"<p>When no predicate is specified, the decorator retries on falsey values:</p> <pre><code>@backoff.on_predicate(backoff.constant, interval=2, max_time=60)\ndef wait_for_resource():\n    # Retries until a truthy value is returned\n    return resource.get() or None\n</code></pre>"},{"location":"user-guide/decorators/#custom-predicates","title":"Custom Predicates","text":"<p>Define specific conditions for retry:</p> <pre><code>@backoff.on_predicate(\n    backoff.expo,\n    lambda result: result[\"status\"] == \"pending\",\n    max_time=600\n)\ndef poll_job_status(job_id):\n    return api.get_job(job_id)\n</code></pre>"},{"location":"user-guide/decorators/#combining-predicates","title":"Combining Predicates","text":"<pre><code>def needs_retry(result):\n    return (\n        result is None or\n        result.get(\"status\") in [\"pending\", \"processing\"] or\n        not result.get(\"ready\", False)\n    )\n\n@backoff.on_predicate(backoff.fibo, needs_retry, max_value=60)\ndef complex_poll(resource_id):\n    return api.get_resource(resource_id)\n</code></pre>"},{"location":"user-guide/decorators/#combining-decorators","title":"Combining Decorators","text":"<p>Stack multiple decorators for complex retry logic:</p> <pre><code>@backoff.on_predicate(backoff.fibo, lambda x: x is None, max_value=13)\n@backoff.on_exception(backoff.expo,\n                      requests.exceptions.HTTPError,\n                      max_time=60)\n@backoff.on_exception(backoff.expo,\n                      requests.exceptions.Timeout,\n                      max_time=300)\ndef robust_poll(endpoint):\n    response = requests.get(endpoint)\n    response.raise_for_status()\n    data = response.json()\n    return data if data.get(\"ready\") else None\n</code></pre> <p>The decorators are applied from bottom to top (inside out), so:</p> <ol> <li>Timeout exceptions get up to 300s of retries</li> <li>HTTP errors get up to 60s of retries</li> <li>None results trigger fibonacci backoff up to 13s</li> </ol>"},{"location":"user-guide/decorators/#event-handler-details","title":"Event Handler Details","text":"<p>Event handlers receive a dictionary with these keys:</p> <pre><code>{\n    'target': &lt;function reference&gt;,\n    'args': &lt;positional args tuple&gt;,\n    'kwargs': &lt;keyword args dict&gt;,\n    'tries': &lt;number of tries so far&gt;,\n    'elapsed': &lt;elapsed time in seconds&gt;,\n    'wait': &lt;seconds to wait&gt;,  # on_backoff only\n    'value': &lt;return value&gt;,    # on_predicate only\n    'exception': &lt;exception&gt;,   # on_exception only\n}\n</code></pre> <p>Example handler:</p> <pre><code>def detailed_log(details):\n    print(f\"Try {details['tries']}: \"\n          f\"elapsed={details['elapsed']:.2f}s, \"\n          f\"wait={details.get('wait', 0):.2f}s\")\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=detailed_log,\n    max_tries=5\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/","title":"Event Handlers","text":"<p>Use event handlers to monitor, log, and react to retry events.</p>"},{"location":"user-guide/event-handlers/#overview","title":"Overview","text":"<p>Backoff decorators accept three types of event handlers:</p> <ul> <li>on_success - Called when function succeeds</li> <li>on_backoff - Called before each retry wait</li> <li>on_giveup - Called when all retries are exhausted</li> </ul>"},{"location":"user-guide/event-handlers/#handler-signature","title":"Handler Signature","text":"<p>All handlers must accept a single <code>dict</code> argument containing event details:</p> <pre><code>def my_handler(details):\n    print(f\"Event details: {details}\")\n</code></pre>"},{"location":"user-guide/event-handlers/#available-details","title":"Available Details","text":"<p>The <code>details</code> dict contains:</p> Key Type Description Available In <code>target</code> function Function being called All handlers <code>args</code> tuple Positional arguments All handlers <code>kwargs</code> dict Keyword arguments All handlers <code>tries</code> int Number of attempts so far All handlers <code>elapsed</code> float Total elapsed time (seconds) All handlers <code>wait</code> float Seconds to wait before retry <code>on_backoff</code> <code>value</code> any Return value that triggered retry <code>on_predicate</code> + <code>on_backoff/giveup</code> <code>exception</code> Exception Exception that was raised <code>on_exception</code> + <code>on_backoff/giveup</code>"},{"location":"user-guide/event-handlers/#on_success-handler","title":"on_success Handler","text":"<p>Called when the function completes successfully.</p> <pre><code>def log_success(details):\n    print(f\"{details['target'].__name__} succeeded after {details['tries']} tries\")\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_success=log_success\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#on_backoff-handler","title":"on_backoff Handler","text":"<p>Called before each retry wait period.</p> <pre><code>def log_backoff(details):\n    print(\n        f\"Backing off {details['wait']:.1f}s after {details['tries']} tries \"\n        f\"(elapsed: {details['elapsed']:.1f}s)\"\n    )\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=log_backoff\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#accessing-exception-info","title":"Accessing Exception Info","text":"<p>For <code>on_exception</code>, the exception is available:</p> <pre><code>def log_exception_backoff(details):\n    exc = details.get('exception')\n    print(f\"Retrying due to: {type(exc).__name__}: {exc}\")\n\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    on_backoff=log_exception_backoff\n)\ndef api_call():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#accessing-return-value","title":"Accessing Return Value","text":"<p>For <code>on_predicate</code>, the return value is available:</p> <pre><code>def log_value_backoff(details):\n    value = details.get('value')\n    print(f\"Retrying because value was: {value}\")\n\n@backoff.on_predicate(\n    backoff.constant,\n    lambda x: x is None,\n    on_backoff=log_value_backoff,\n    interval=2\n)\ndef poll_resource():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#on_giveup-handler","title":"on_giveup Handler","text":"<p>Called when retries are exhausted.</p> <pre><code>def log_giveup(details):\n    print(\n        f\"Giving up on {details['target'].__name__} \"\n        f\"after {details['tries']} tries and {details['elapsed']:.1f}s\"\n    )\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_giveup=log_giveup,\n    max_tries=5\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#multiple-handlers","title":"Multiple Handlers","text":"<p>You can provide multiple handlers as a list:</p> <pre><code>def log_to_console(details):\n    print(f\"Retry #{details['tries']}\")\n\ndef log_to_file(details):\n    with open('retries.log', 'a') as f:\n        f.write(f\"Retry #{details['tries']}\\\\n\")\n\ndef send_metric(details):\n    metrics.increment('retry_count')\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=[log_to_console, log_to_file, send_metric]\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/event-handlers/#structured-logging","title":"Structured Logging","text":"<pre><code>import logging\nimport json\n\nlogger = logging.getLogger(__name__)\n\ndef structured_log_backoff(details):\n    logger.warning(json.dumps({\n        'event': 'retry',\n        'function': details['target'].__name__,\n        'tries': details['tries'],\n        'wait': details['wait'],\n        'elapsed': details['elapsed']\n    }))\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=structured_log_backoff\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#metrics-collection","title":"Metrics Collection","text":"<pre><code>from prometheus_client import Counter, Histogram\n\nretry_counter = Counter('backoff_retries_total', 'Total retries', ['function'])\nretry_duration = Histogram('backoff_retry_duration_seconds', 'Retry duration')\n\ndef record_metrics(details):\n    retry_counter.labels(function=details['target'].__name__).inc()\n    retry_duration.observe(details['elapsed'])\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=record_metrics\n)\ndef monitored_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#error-tracking","title":"Error Tracking","text":"<pre><code>import sentry_sdk\n\ndef report_to_sentry(details):\n    if details['tries'] &gt; 3:  # Only report after 3 failures\n        sentry_sdk.capture_message(\n            f\"Multiple retries for {details['target'].__name__}\",\n            level='warning',\n            extra=details\n        )\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=report_to_sentry\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#alerting","title":"Alerting","text":"<pre><code>def alert_on_giveup(details):\n    if details['tries'] &gt;= 5:\n        send_alert(\n            f\"Function {details['target'].__name__} failed \"\n            f\"after {details['tries']} attempts\"\n        )\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_giveup=alert_on_giveup,\n    max_tries=5\n)\ndef critical_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#async-event-handlers","title":"Async Event Handlers","text":"<p>Event handlers can be async when used with async functions:</p> <pre><code>import aiohttp\n\nasync def async_log_backoff(details):\n    async with aiohttp.ClientSession() as session:\n        await session.post(\n            'http://log-service/events',\n            json=details\n        )\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=async_log_backoff\n)\nasync def async_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#exception-access","title":"Exception Access","text":"<p>In <code>on_exception</code> handlers, you can access exception info:</p> <pre><code>import sys\nimport traceback\n\ndef detailed_exception_log(details):\n    exc_type, exc_value, exc_tb = sys.exc_info()\n    tb_str = ''.join(traceback.format_tb(exc_tb))\n\n    logger.error(\n        f\"Retry {details['tries']} due to {exc_type.__name__}: {exc_value}\\\\n\"\n        f\"Traceback:\\\\n{tb_str}\"\n    )\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=detailed_exception_log\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#conditional-handlers","title":"Conditional Handlers","text":"<p>Execute handler logic conditionally:</p> <pre><code>def conditional_alert(details):\n    # Only alert after many retries\n    if details['tries'] &gt;= 5:\n        send_alert(f\"High retry count: {details['tries']}\")\n\n    # Only log errors, not warnings\n    if details.get('exception'):\n        if isinstance(details['exception'], CriticalError):\n            logger.error(\"Critical error during retry\")\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    on_backoff=conditional_alert\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/event-handlers/#complete-example","title":"Complete Example","text":"<pre><code>import logging\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\ndef log_attempt(details):\n    logger.info(\n        f\"[{datetime.now()}] Attempt {details['tries']} \"\n        f\"for {details['target'].__name__}\"\n    )\n\ndef log_backoff(details):\n    logger.warning(\n        f\"Backing off {details['wait']:.1f}s after {details['tries']} tries. \"\n        f\"Total elapsed: {details['elapsed']:.1f}s. \"\n        f\"Error: {details.get('exception', 'N/A')}\"\n    )\n\ndef log_giveup(details):\n    logger.error(\n        f\"Gave up on {details['target'].__name__} after \"\n        f\"{details['tries']} tries and {details['elapsed']:.1f}s. \"\n        f\"Final error: {details.get('exception', 'N/A')}\"\n    )\n\ndef log_success(details):\n    logger.info(\n        f\"Success for {details['target'].__name__} after \"\n        f\"{details['tries']} tries in {details['elapsed']:.1f}s\"\n    )\n\n@backoff.on_exception(\n    backoff.expo,\n    requests.exceptions.RequestException,\n    max_tries=5,\n    max_time=60,\n    on_backoff=[log_attempt, log_backoff],\n    on_giveup=log_giveup,\n    on_success=log_success\n)\ndef comprehensive_retry():\n    return requests.get(\"https://api.example.com/data\")\n</code></pre>"},{"location":"user-guide/logging/","title":"Logging","text":"<p>Configure logging for backoff retry events.</p>"},{"location":"user-guide/logging/#default-logger","title":"Default Logger","text":"<p>Backoff uses the <code>'backoff'</code> logger by default. It's configured with a <code>NullHandler</code>, so nothing is output unless you configure it.</p>"},{"location":"user-guide/logging/#basic-setup","title":"Basic Setup","text":"<pre><code>import logging\n\n# Enable backoff logging\nlogging.getLogger('backoff').addHandler(logging.StreamHandler())\nlogging.getLogger('backoff').setLevel(logging.INFO)\n</code></pre>"},{"location":"user-guide/logging/#log-levels","title":"Log Levels","text":"<ul> <li>INFO - Logs all retry attempts</li> <li>ERROR - Logs only when giving up</li> <li>WARNING - Custom level for important retries</li> <li>DEBUG - Detailed information</li> </ul> <pre><code># Only log when giving up\nlogging.getLogger('backoff').setLevel(logging.ERROR)\n\n# Log all retries\nlogging.getLogger('backoff').setLevel(logging.INFO)\n</code></pre>"},{"location":"user-guide/logging/#custom-logger","title":"Custom Logger","text":"<p>Specify a custom logger by name or instance.</p>"},{"location":"user-guide/logging/#logger-by-name","title":"Logger by Name","text":"<pre><code>@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    logger='my_custom_logger'\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/logging/#logger-instance","title":"Logger Instance","text":"<pre><code>import logging\n\nmy_logger = logging.getLogger('my_app.retries')\nmy_logger.addHandler(logging.FileHandler('retries.log'))\nmy_logger.setLevel(logging.WARNING)\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    logger=my_logger\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/logging/#disable-logging","title":"Disable Logging","text":"<p>Pass <code>logger=None</code> to disable all default logging:</p> <pre><code>@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    logger=None\n)\ndef my_function():\n    pass\n</code></pre> <p>Use with custom event handlers for complete control:</p> <pre><code>def my_custom_log(details):\n    print(f\"Custom log: {details}\")\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    logger=None,\n    on_backoff=my_custom_log\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/logging/#formatting","title":"Formatting","text":""},{"location":"user-guide/logging/#basic-format","title":"Basic Format","text":"<pre><code>import logging\n\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    level=logging.INFO\n)\n\nlogging.getLogger('backoff').addHandler(logging.StreamHandler())\n</code></pre>"},{"location":"user-guide/logging/#structured-logging-json","title":"Structured Logging (JSON)","text":"<pre><code>import logging\nimport json\n\nclass JsonFormatter(logging.Formatter):\n    def format(self, record):\n        log_data = {\n            'timestamp': self.formatTime(record),\n            'level': record.levelname,\n            'logger': record.name,\n            'message': record.getMessage()\n        }\n        return json.dumps(log_data)\n\nhandler = logging.StreamHandler()\nhandler.setFormatter(JsonFormatter())\n\nbackoff_logger = logging.getLogger('backoff')\nbackoff_logger.addHandler(handler)\nbackoff_logger.setLevel(logging.INFO)\n</code></pre>"},{"location":"user-guide/logging/#multiple-handlers","title":"Multiple Handlers","text":"<p>Send logs to multiple destinations:</p> <pre><code>import logging\n\nbackoff_logger = logging.getLogger('backoff')\n\n# Console handler\nconsole_handler = logging.StreamHandler()\nconsole_handler.setLevel(logging.WARNING)\n\n# File handler\nfile_handler = logging.FileHandler('backoff.log')\nfile_handler.setLevel(logging.INFO)\n\n# Add both handlers\nbackoff_logger.addHandler(console_handler)\nbackoff_logger.addHandler(file_handler)\nbackoff_logger.setLevel(logging.INFO)\n</code></pre>"},{"location":"user-guide/logging/#per-function-logging","title":"Per-Function Logging","text":"<p>Use different loggers for different functions:</p> <pre><code>critical_logger = logging.getLogger('critical_ops')\nroutine_logger = logging.getLogger('routine_ops')\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    logger=critical_logger,\n    max_tries=10\n)\ndef critical_operation():\n    pass\n\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    logger=routine_logger,\n    max_tries=3\n)\ndef routine_operation():\n    pass\n</code></pre>"},{"location":"user-guide/logging/#complete-example","title":"Complete Example","text":"<pre><code>import logging\nfrom logging.handlers import RotatingFileHandler\n\n# Create custom logger\nlogger = logging.getLogger('myapp.backoff')\nlogger.setLevel(logging.INFO)\n\n# Console handler with WARNING level\nconsole_handler = logging.StreamHandler()\nconsole_handler.setLevel(logging.WARNING)\nconsole_format = logging.Formatter(\n    '%(levelname)s: %(message)s'\n)\nconsole_handler.setFormatter(console_format)\n\n# File handler with INFO level and rotation\nfile_handler = RotatingFileHandler(\n    'backoff.log',\n    maxBytes=10*1024*1024,  # 10MB\n    backupCount=5\n)\nfile_handler.setLevel(logging.INFO)\nfile_format = logging.Formatter(\n    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nfile_handler.setFormatter(file_format)\n\n# Add handlers\nlogger.addHandler(console_handler)\nlogger.addHandler(file_handler)\n\n# Use in decorator\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    logger=logger,\n    max_tries=5\n)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/wait-strategies/","title":"Wait Strategies","text":"<p>Backoff provides several built-in wait strategies (generators) that determine how long to wait between retries.</p>"},{"location":"user-guide/wait-strategies/#exponential-expo","title":"Exponential (expo)","text":"<p>Exponential backoff doubles the wait time after each retry.</p> <pre><code>import backoff\n\n@backoff.on_exception(backoff.expo, Exception)\ndef my_function():\n    pass\n</code></pre> <p>Wait sequence (without jitter): 1s, 2s, 4s, 8s, 16s, 32s, ...</p>"},{"location":"user-guide/wait-strategies/#parameters","title":"Parameters","text":"<ul> <li>base - Base wait time in seconds (default: 1)</li> <li>factor - Multiplier for each iteration (default: 2)</li> <li>max_value - Maximum wait time cap (default: None)</li> </ul>"},{"location":"user-guide/wait-strategies/#examples","title":"Examples","text":"<pre><code># Custom base and factor\n@backoff.on_exception(\n    backoff.expo,\n    Exception,\n    base=2,      # Start at 2 seconds\n    factor=3,    # Triple each time\n    max_value=60 # Cap at 60 seconds\n)\ndef custom_expo():\n    pass\n# Wait sequence: 2s, 6s, 18s, 54s, 60s, 60s, ...\n</code></pre>"},{"location":"user-guide/wait-strategies/#best-for","title":"Best For","text":"<ul> <li>API rate limiting</li> <li>Network requests</li> <li>Database connections</li> <li>Most general-purpose retries</li> </ul>"},{"location":"user-guide/wait-strategies/#fibonacci-fibo","title":"Fibonacci (fibo)","text":"<p>Fibonacci backoff follows the Fibonacci sequence.</p> <pre><code>@backoff.on_exception(backoff.fibo, Exception)\ndef my_function():\n    pass\n</code></pre> <p>Wait sequence (without jitter): 1s, 1s, 2s, 3s, 5s, 8s, 13s, 21s, ...</p>"},{"location":"user-guide/wait-strategies/#parameters_1","title":"Parameters","text":"<ul> <li>max_value - Maximum wait time cap (default: None)</li> </ul>"},{"location":"user-guide/wait-strategies/#examples_1","title":"Examples","text":"<pre><code>@backoff.on_exception(\n    backoff.fibo,\n    Exception,\n    max_value=30  # Cap at 30 seconds\n)\ndef fibo_with_cap():\n    pass\n# Wait sequence: 1s, 1s, 2s, 3s, 5s, 8s, 13s, 21s, 30s, 30s, ...\n</code></pre>"},{"location":"user-guide/wait-strategies/#best-for_1","title":"Best For","text":"<ul> <li>Gradual backoff when you want slower growth than exponential</li> <li>Polling operations</li> <li>Resource-constrained environments</li> </ul>"},{"location":"user-guide/wait-strategies/#constant","title":"Constant","text":"<p>Fixed wait time between all retries.</p> <pre><code>@backoff.on_exception(\n    backoff.constant,\n    Exception,\n    interval=5  # Always wait 5 seconds\n)\ndef my_function():\n    pass\n</code></pre> <p>Wait sequence: 5s, 5s, 5s, 5s, ...</p>"},{"location":"user-guide/wait-strategies/#parameters_2","title":"Parameters","text":"<ul> <li>interval - Wait time in seconds (default: 1)</li> </ul>"},{"location":"user-guide/wait-strategies/#examples_2","title":"Examples","text":"<pre><code># Poll every 10 seconds\n@backoff.on_predicate(\n    backoff.constant,\n    interval=10,\n    jitter=None,  # Disable jitter for exact intervals\n    max_time=300\n)\ndef poll_every_10_seconds():\n    pass\n</code></pre>"},{"location":"user-guide/wait-strategies/#best-for_2","title":"Best For","text":"<ul> <li>Regular polling</li> <li>Fixed-rate retry policies</li> <li>Cases where jitter is disabled</li> </ul>"},{"location":"user-guide/wait-strategies/#runtime","title":"Runtime","text":"<p>Dynamic wait time based on function return value or exception.</p> <pre><code>@backoff.on_predicate(\n    backoff.runtime,\n    predicate=lambda r: r.status_code == 429,\n    value=lambda r: int(r.headers.get(\"Retry-After\", 1))\n)\ndef respect_retry_after():\n    return requests.get(url)\n</code></pre>"},{"location":"user-guide/wait-strategies/#parameters_3","title":"Parameters","text":"<ul> <li>value - Function that extracts wait time from return value or exception</li> </ul>"},{"location":"user-guide/wait-strategies/#examples_3","title":"Examples","text":""},{"location":"user-guide/wait-strategies/#http-retry-after-header","title":"HTTP Retry-After Header","text":"<pre><code>def get_retry_after(response):\n    \"\"\"Extract Retry-After from HTTP response\"\"\"\n    if response.status_code == 429:\n        retry_after = response.headers.get(\"Retry-After\")\n        if retry_after:\n            return int(retry_after)\n    return 1  # Default\n\n@backoff.on_predicate(\n    backoff.runtime,\n    predicate=lambda r: r.status_code == 429,\n    value=get_retry_after,\n    jitter=None\n)\ndef api_call():\n    return requests.get(api_url)\n</code></pre>"},{"location":"user-guide/wait-strategies/#exception-based-wait-time","title":"Exception-based Wait Time","text":"<pre><code>class RetryableError(Exception):\n    def __init__(self, message, wait_seconds):\n        super().__init__(message)\n        self.wait_seconds = wait_seconds\n\n@backoff.on_exception(\n    backoff.runtime,\n    RetryableError,\n    value=lambda e: e.wait_seconds\n)\ndef custom_retry():\n    raise RetryableError(\"Try again\", wait_seconds=30)\n</code></pre>"},{"location":"user-guide/wait-strategies/#best-for_3","title":"Best For","text":"<ul> <li>Respecting server-specified retry delays</li> <li>Custom retry logic from application responses</li> <li>API rate limiting with Retry-After headers</li> </ul>"},{"location":"user-guide/wait-strategies/#jitter","title":"Jitter","text":"<p>All wait strategies support jitter to add randomness and prevent thundering herd problems.</p>"},{"location":"user-guide/wait-strategies/#full_jitter-default","title":"full_jitter (default)","text":"<p>Uses AWS's Full Jitter algorithm - wait time is random between 0 and the calculated wait.</p> <pre><code>@backoff.on_exception(backoff.expo, Exception)\n# Equivalent to:\n@backoff.on_exception(backoff.expo, Exception, jitter=backoff.full_jitter)\n</code></pre> <p>For exponential backoff: actual wait is random between 0 and 2^n seconds.</p>"},{"location":"user-guide/wait-strategies/#random_jitter","title":"random_jitter","text":"<p>Adds random milliseconds (0-1000ms) to the calculated wait time.</p> <pre><code>@backoff.on_exception(backoff.expo, Exception, jitter=backoff.random_jitter)\n</code></pre>"},{"location":"user-guide/wait-strategies/#custom-jitter","title":"Custom Jitter","text":"<pre><code>import random\n\ndef custom_jitter(value):\n    \"\"\"Add 10-50% randomness\"\"\"\n    jitter_amount = value * random.uniform(0.1, 0.5)\n    return value + jitter_amount\n\n@backoff.on_exception(backoff.expo, Exception, jitter=custom_jitter)\ndef my_function():\n    pass\n</code></pre>"},{"location":"user-guide/wait-strategies/#disable-jitter","title":"Disable Jitter","text":"<pre><code>@backoff.on_exception(backoff.expo, Exception, jitter=None)\n</code></pre>"},{"location":"user-guide/wait-strategies/#comparison","title":"Comparison","text":"Strategy Growth Rate Use Case Example Sequence (5 iterations) expo Fast Network, APIs 1s, 2s, 4s, 8s, 16s fibo Medium Polling 1s, 1s, 2s, 3s, 5s constant None Fixed intervals 5s, 5s, 5s, 5s, 5s runtime Variable Server-directed Depends on response"},{"location":"user-guide/wait-strategies/#choosing-a-strategy","title":"Choosing a Strategy","text":"<p>Use exponential when:</p> <ul> <li>You want fast backoff for transient failures</li> <li>Dealing with network or API calls</li> <li>Following industry best practices</li> </ul> <p>Use fibonacci when:</p> <ul> <li>You want gentler backoff than exponential</li> <li>Resource constraints matter</li> <li>Polling for long-running operations</li> </ul> <p>Use constant when:</p> <ul> <li>You need predictable, fixed intervals</li> <li>Polling at specific rates</li> <li>Testing or debugging</li> </ul> <p>Use runtime when:</p> <ul> <li>Server tells you how long to wait</li> <li>Retry delay is in the response/exception</li> <li>Implementing Retry-After headers</li> </ul>"}]}